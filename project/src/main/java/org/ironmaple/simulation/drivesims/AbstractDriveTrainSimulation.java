package org.ironmaple.simulation.drivesims;

import static edu.wpi.first.units.Units.Meters;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import org.dyn4j.dynamics.Body;
import org.dyn4j.geometry.Geometry;
import org.dyn4j.geometry.MassType;
import org.ironmaple.simulation.drivesims.configs.DriveTrainSimulationConfig;
import org.ironmaple.utils.mathutils.GeometryConvertor;

/**
 *
 *
 * <h1>Represents an Abstract Drivetrain Simulation.</h1>
 *
 * <h3>Simulates the Mass, Collision Space, and Friction of the Drivetrain.</h3>
 *
 * <p>This class models the physical properties of a drivetrain, including mass and collision space.
 *
 * <p>It also provides APIs to obtain the status (position, velocity etc.) in WPILib geometry classes.
 *
 * <p>The propelling forces generated by motors are simulated in its subclass, or {@link SwerveDriveSimulation}.
 */
public abstract class AbstractDriveTrainSimulation extends Body {
    public static final double
            BUMPER_COEFFICIENT_OF_FRICTION = 0.65, // https://en.wikipedia.org/wiki/Friction#Coefficient_of_friction
            BUMPER_COEFFICIENT_OF_RESTITUTION = 0.08; // https://simple.wikipedia.org/wiki/Coefficient_of_restitution

    public final DriveTrainSimulationConfig config;

    /**
     *
     *
     * <h2>Creates a Simulation of a Drivetrain.</h2>
     *
     * <h3>Sets Up the Collision Space and Mass of the Chassis.</h3>
     *
     * <p>Since this is an abstract class, the constructor must be called from a subclass.
     *
     * <p>Note that the chassis does not appear on the simulation field upon creation. Refer to
     * {@link org.ironmaple.simulation.SimulatedArena} for instructions on how to add it to the simulation world.
     *
     * @param config a {@link DriveTrainSimulationConfig} instance containing the configurations of this drivetrain
     * @param initialPoseOnField the initial pose of the drivetrain in the simulation world
     */
    protected AbstractDriveTrainSimulation(DriveTrainSimulationConfig config, Pose2d initialPoseOnField) {

        this.config = config;
        /* width and height in world reference is flipped */
        final double WIDTH_IN_WORLD_REFERENCE = config.bumperLengthX.in(Meters),
                HEIGHT_IN_WORLD_REFERENCE = config.bumperWidthY.in(Meters);

        super.addFixture(
                Geometry.createRectangle(WIDTH_IN_WORLD_REFERENCE, HEIGHT_IN_WORLD_REFERENCE),
                config.getDensityKgPerSquaredMeters(),
                BUMPER_COEFFICIENT_OF_FRICTION,
                BUMPER_COEFFICIENT_OF_RESTITUTION);

        super.setMass(MassType.NORMAL);
        super.setLinearDamping(0.1);
        super.setAngularDamping(0.1);
        setSimulationWorldPose(initialPoseOnField);
    }

    /**
     *
     *
     * <h2>Sets the Robot's Current Pose in the Simulation World.</h2>
     *
     * <p>This method instantly teleports the robot to the specified pose in the simulation world. The robot does not
     * drive to the new pose; it is moved directly.
     *
     * @param robotPose the desired robot pose, represented as a {@link Pose2d}
     */
    public void setSimulationWorldPose(Pose2d robotPose) {
        super.transform.set(GeometryConvertor.toDyn4jTransform(robotPose));
        super.linearVelocity.set(0, 0);
    }

    /**
     *
     *
     * <h2>Sets the Robot's Speeds to the Given Chassis Speeds.</h2>
     *
     * <p>This method sets the robot's current velocity to the specified chassis speeds.
     *
     * <p>The robot does not accelerate smoothly to these speeds; instead, it jumps to the velocity
     * <strong>Instantaneously</strong>.
     *
     * @param givenSpeeds the desired chassis speeds, represented as a {@link ChassisSpeeds} object
     */
    public void setRobotSpeeds(ChassisSpeeds givenSpeeds) {
        super.setLinearVelocity(GeometryConvertor.toDyn4jLinearVelocity(givenSpeeds));
        super.setAngularVelocity(givenSpeeds.omegaRadiansPerSecond);
    }

    /**
     *
     *
     * <h2>Abstract Simulation Sub-Tick Method.</h2>
     *
     * <p>This method is called every time the simulation world is updated.
     *
     * <p>It is implemented in the sub-classes of {@link AbstractDriveTrainSimulation}.
     *
     * <p>It is responsible for applying the propelling forces to the robot during each sub-tick of the simulation.
     */
    public abstract void simulationSubTick();

    /**
     *
     *
     * <h2>Gets the Actual Pose of the Drivetrain in the Simulation World.</h2>
     *
     * <p>This method is used to display the robot on <a
     * href="https://docs.advantagescope.org/tab-reference/3d-field/">AdvantageScope Field3d</a> or to <a
     * href="https://docs.photonvision.org/en/latest/docs/simulation/simulation-java.html#updating-the-simulation-world">update
     * vision simulations</a>.
     *
     * <p><strong>Note:</strong> Do not use this method to simulate odometry! For a more realistic odometry simulation,
     * use a {@link SwerveDriveSimulation} together with a
     * {@link edu.wpi.first.math.estimator.SwerveDrivePoseEstimator}.
     *
     * @return a {@link Pose2d} object yielding the current world pose of the robot in the simulation
     */
    public Pose2d getSimulatedDriveTrainPose() {
        return GeometryConvertor.toWpilibPose2d(getTransform());
    }

    /**
     *
     *
     * <h2>Gets the Actual Robot-Relative Chassis Speeds from the Simulation.</h2>
     *
     * <p>This method returns the actual chassis speeds of the drivetrain in the simulation, relative to the robot.
     *
     * <p>To simulate the chassis speeds calculated by encoders, use a {@link SwerveDriveSimulation} together with
     * {@link edu.wpi.first.math.kinematics.SwerveDriveKinematics#toChassisSpeeds(SwerveModuleState...)} for a more
     * realistic simulation.
     *
     * @return the actual chassis speeds in the simulation world, <strong>Robot-Relative</strong>
     */
    public ChassisSpeeds getDriveTrainSimulatedChassisSpeedsRobotRelative() {
        ChassisSpeeds speeds = getDriveTrainSimulatedChassisSpeedsFieldRelative();
        speeds.toRobotRelativeSpeeds(getSimulatedDriveTrainPose().getRotation());
        return speeds;
    }

    /**
     *
     *
     * <h2>Gets the Actual Field-Relative Chassis Speeds from the Simulation.</h2>
     *
     * <p>This method returns the actual chassis speeds of the drivetrain in the simulation, relative to the robot.
     *
     * <p>To simulate the chassis speeds calculated by encoders, use a {@link SwerveDriveSimulation} together with
     * {@link edu.wpi.first.math.kinematics.SwerveDriveKinematics#toChassisSpeeds(SwerveModuleState...)} for a more
     * realistic simulation.
     *
     * @return the actual chassis speeds in the simulation world, <strong>Field-Relative</strong>
     */
    public ChassisSpeeds getDriveTrainSimulatedChassisSpeedsFieldRelative() {
        return GeometryConvertor.toWpilibChassisSpeeds(getLinearVelocity(), getAngularVelocity());
    }
}
