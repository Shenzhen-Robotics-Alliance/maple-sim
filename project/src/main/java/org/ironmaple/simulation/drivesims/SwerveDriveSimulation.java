package org.ironmaple.simulation.drivesims;

import static edu.wpi.first.units.Units.*;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.units.measure.*;
import java.util.Arrays;
import java.util.function.Supplier;
import org.dyn4j.geometry.Vector2;
import org.ironmaple.simulation.SimulatedArena;
import org.ironmaple.simulation.drivesims.configs.DriveTrainSimulationConfig;
import org.ironmaple.utils.mathutils.GeometryConvertor;

/**
 *
 *
 * <h1>Simulates a Swerve Drivetrain.</h1>
 *
 * <p>Check <a href='https://shenzhen-robotics-alliance.github.io/maple-sim/swerve-simulation-overview/'>Online
 * Documentation</a>
 *
 * <h3>1. Purpose</h3>
 *
 * <p>This class simulates a swerve drivetrain composed of more than two {@link SwerveModuleSimulation} modules.
 *
 * <p>It provides a realistic modeling of drivetrain physics, replicating wheel grip and motor propulsion for an actual
 * swerve drive.
 *
 * <h3>2. Simulation Dynamics</h3>
 *
 * <ul>
 *   <li>1. Propelling forces generated by the drive motors, computed by
 *       {@link SwerveModuleSimulation#updateSimulationSubTickGetModuleForce(Vector2, Rotation2d, double)}.
 *   <li>2. Friction forces generated by the wheels that "pull" the robot from its current ground velocity to the module
 *       velocities, both translational and rotational.
 *   <li>3. Centripetal forces generated by the steering when the drivetrain makes a turn.
 * </ul>
 *
 * <h3>3. Odometry Simulation</h3>
 *
 * <p>To simulate odometry, follow these steps:
 *
 * <ul>
 *   <li>Obtain the {@link SwerveModuleSimulation} instances through {@link #getModules()}.
 *   <li>Create an <a href='https://github.com/Mechanical-Advantage/AdvantageKit/blob/main/docs/RECORDING-INPUTS.md'>IO
 *       Implementation</a> that wraps around {@link SwerveModuleSimulation} to retrieve encoder readings.
 *   <li>Update a {@link edu.wpi.first.math.estimator.SwerveDrivePoseEstimator} using the encoder readings, similar to
 *       how you would on a real robot.
 * </ul>
 *
 * <p>Refer to the <a
 * href='https://github.com/Shenzhen-Robotics-Alliance/maple-sim/blob/main/templates/AdvantageKit_AdvancedSwerveDriveProject/src/main/java/frc/robot/subsystems/drive/ModuleIOSim.java'>ModuleIOSim.java</a>
 * example project for more details.
 *
 * <h3>Vision Simulation</h3>
 *
 * <p>You can obtain the real robot pose from {@link #getSimulatedDriveTrainPose()} and feed it to the <a
 * href="https://docs.photonvision.org/en/latest/docs/simulation/simulation-java.html#updating-the-simulation-world">PhotonVision
 * simulation</a> to simulate vision.
 */
public class SwerveDriveSimulation extends AbstractDriveTrainSimulation {
    private final SwerveModuleSimulation[] moduleSimulations;
    protected final GyroSimulation gyroSimulation;
    protected final Translation2d[] moduleTranslations;
    protected final SwerveDriveKinematics kinematics;
    private final Translation2d centerOfMassOffset;
    private final double totalWeightNewtons;
    private ChassisSpeeds previousChassisSpeeds = new ChassisSpeeds();

    /**
     *
     *
     * <h2>Creates a Swerve Drive Simulation.</h2>
     *
     * <p>This constructor initializes a swerve drive simulation with the given robot mass, bumper dimensions, module
     * simulations, module translations, gyro simulation, and initial pose on the field.
     *
     * @param config a {@link DriveTrainSimulationConfig} instance containing the configurations of * this drivetrain
     * @param initialPoseOnField the initial pose of the drivetrain in the simulation world, represented as a
     *     {@link Pose2d}
     */
    public SwerveDriveSimulation(DriveTrainSimulationConfig config, Pose2d initialPoseOnField) {
        super(config, initialPoseOnField);
        this.moduleTranslations = config.moduleTranslations;
        this.moduleSimulations = Arrays.stream(config.swerveModuleSimulationFactories)
                .map(Supplier::get)
                .toArray(SwerveModuleSimulation[]::new);
        this.gyroSimulation = config.gyroSimulationFactory.get();

        super.setLinearDamping(1.4);
        super.setAngularDamping(1.4);
        this.kinematics = new SwerveDriveKinematics(moduleTranslations);

        this.centerOfMassOffset = new Translation2d(config.centerOfMass.getX(), config.centerOfMass.getY());
        this.totalWeightNewtons = config.robotMass.in(Kilograms) * 9.8;
    }

    /**
     *
     *
     * <h2>Updates the Swerve Drive Simulation.</h2>
     *
     * <p>This method performs the following actions during each sub-tick of the simulation:
     *
     * <ul>
     *   <li>Applies friction forces per module to the physics engine (handles both translation and rotation).
     *   <li>Updates the simulation of each swerve module.
     *   <li>Applies the propelling forces of the modules to the physics engine.
     *   <li>Updates the gyro simulation of the drivetrain.
     * </ul>
     */
    @Override
    public void simulationSubTick() {
        final double[] currentGravityForces = calculateDynamicWeightDistribution();

        simulateModuleFrictionForces(currentGravityForces);

        simulateModulePropellingForces(currentGravityForces);

        gyroSimulation.updateSimulationSubTick(super.getAngularVelocity());

        // Update previous chassis speeds for next iteration
        previousChassisSpeeds = getDriveTrainSimulatedChassisSpeedsRobotRelative();
    }

    /**
     *
     *
     * <h2>Simulates the Friction Forces Per Module and Applies Them to the Physics Engine.</h2>
     *
     * <p>This method simulates the friction forces acting on each module individually. The friction force pulls each
     * module from its current ground velocity toward its desired module velocity.
     *
     * <p>By applying forces at each module position, both translational and rotational friction effects are naturally
     * handled through the physics engine's torque calculations.
     *
     * <p>The friction force for each module should not exceed that module's grip limit based on its weight
     * distribution.
     */
    private void simulateModuleFrictionForces(double[] currentGravityForces) {
        final double FRICTION_FORCE_GAIN = 3.0;
        final Rotation2d robotRotation = getSimulatedDriveTrainPose().getRotation();

        for (int i = 0; i < moduleSimulations.length; i++) {
            // Get module position and current ground velocity
            final Vector2 moduleWorldPosition = getWorldPoint(GeometryConvertor.toDyn4jVector2(moduleTranslations[i]));
            final Vector2 moduleGroundVelocity = super.getLinearVelocity(moduleWorldPosition);

            // Get module's desired velocity from its current state
            final SwerveModuleState moduleState = moduleSimulations[i].getCurrentState();
            final Rotation2d moduleWorldFacing = moduleState.angle.plus(robotRotation);
            final Vector2 desiredModuleVelocity =
                    Vector2.create(moduleState.speedMetersPerSecond, moduleWorldFacing.getRadians());

            // Calculate velocity difference (direction friction force should pull)
            final Vector2 velocityDifference = new Vector2(
                    desiredModuleVelocity.x - moduleGroundVelocity.x, desiredModuleVelocity.y - moduleGroundVelocity.y);

            // Calculate gripping force for this module
            final double moduleGrippingForce =
                    moduleSimulations[i].config.getGrippingForceNewtons(currentGravityForces[i]);

            // Calculate friction force magnitude (proportional to velocity difference, capped by grip limit)
            final double velocityDiffMagnitude = velocityDifference.getMagnitude();
            final double frictionForceMagnitude =
                    Math.min(FRICTION_FORCE_GAIN * moduleGrippingForce * velocityDiffMagnitude, moduleGrippingForce);

            // Create friction force vector
            Vector2 frictionForce;
            if (velocityDiffMagnitude > 1e-6) {
                frictionForce = Vector2.create(frictionForceMagnitude, velocityDifference.getDirection());
            } else {
                frictionForce = new Vector2(0, 0);
            }

            // Apply force at module position
            if (centerOfMassOffset.getNorm() > 1e-6) {
                // Apply force at module position (Dyn4j will calculate torque relative to geometric center)
                super.applyForce(frictionForce, moduleWorldPosition);

                // Dyn4j calculates: torque_dyn4j = (module - geometricCenter) × F
                // We want: torque_desired = (module - centerOfMass) × F
                // Correction: torque_correction = (geometricCenter - centerOfMass) × F
                final double torqueCorrection =
                        -centerOfMassOffset.getX() * frictionForce.y + centerOfMassOffset.getY() * frictionForce.x;
                super.applyTorque(torqueCorrection);
            } else {
                super.applyForce(frictionForce, moduleWorldPosition);
            }
        }
    }

    /**
     *
     *
     * <h2>Simulates the Propelling Forces Per Module and Applies Them to the Physics Engine.</h2>
     *
     * <p>This method simulates the propelling forces generated by each module's drive motor and applies them to the
     * physics engine. Each module generates a force in its facing direction based on the motor torque, which is capped
     * by the module's gripping force limit.
     *
     * <p>Forces are applied at each module position, allowing the physics engine to automatically calculate the correct
     * torques based on the force application points.
     */
    private void simulateModulePropellingForces(double[] currentGravityForces) {
        for (int i = 0; i < moduleSimulations.length; i++) {
            final Vector2 moduleWorldPosition = getWorldPoint(GeometryConvertor.toDyn4jVector2(moduleTranslations[i]));
            final Vector2 moduleForce = moduleSimulations[i].updateSimulationSubTickGetModuleForce(
                    super.getLinearVelocity(moduleWorldPosition),
                    getSimulatedDriveTrainPose().getRotation(),
                    currentGravityForces[i]);

            // If center of mass is offset, we need to correct the torque calculation
            if (centerOfMassOffset.getNorm() > 1e-6) {
                // Apply force at module position (Dyn4j will calculate torque relative to geometric center)
                super.applyForce(moduleForce, moduleWorldPosition);

                // Dyn4j calculates: torque_dyn4j = (module - geometricCenter) × F
                // We want: torque_desired = (module - centerOfMass) × F
                // Correction: torque_correction = (geometricCenter - centerOfMass) × F
                final double torqueCorrection =
                        -centerOfMassOffset.getX() * moduleForce.y + centerOfMassOffset.getY() * moduleForce.x;
                super.applyTorque(torqueCorrection);
            } else {
                // Default behavior: apply force at module position
                super.applyForce(moduleForce, moduleWorldPosition);
            }
        }
    }

    /**
     *
     *
     * <h2>Obtains the Chassis Speeds the Modules Are Attempting to Achieve.</h2>
     *
     * <p>This method returns the desired chassis speeds that the modules are trying to reach. If the robot maintains
     * the current driving voltage and steering position for a long enough period, it will achieve these speeds.
     *
     * @return the desired chassis speeds, robot-relative
     */
    private ChassisSpeeds getDesiredSpeed() {
        return kinematics.toChassisSpeeds(Arrays.stream(moduleSimulations)
                .map((SwerveModuleSimulation::getFreeSpinState))
                .toArray(SwerveModuleState[]::new));
    }

    /**
     *
     *
     * <h2>Obtains the Current Chassis Speeds of the Modules.</h2>
     *
     * <p>This method estimates the chassis speeds of the robot based on the swerve states of the modules.
     *
     * <p><strong>Note:</strong> These speeds might not represent the actual floor speeds due to potential skidding.
     *
     * @return the module speeds, robot-relative
     */
    private ChassisSpeeds getModuleSpeeds() {
        return kinematics.toChassisSpeeds(Arrays.stream(moduleSimulations)
                .map((SwerveModuleSimulation::getCurrentState))
                .toArray(SwerveModuleState[]::new));
    }

    /**
     *
     *
     * <h2>Obtains the maximum achievable linear velocity of the chassis.</h2>
     *
     * @return the maximum linear velocity
     * @see org.ironmaple.simulation.drivesims.configs.SwerveModuleSimulationConfig#maximumGroundSpeed()
     */
    public LinearVelocity maxLinearVelocity() {
        return moduleSimulations[0].config.maximumGroundSpeed();
    }

    /**
     *
     *
     * <h2>Obtains the maximum achievable linear acceleration of the chassis.</h2>
     *
     * @return the maximum linear acceleration
     * @see org.ironmaple.simulation.drivesims.configs.SwerveModuleSimulationConfig#maxAcceleration(Mass, int, Current)
     */
    public LinearAcceleration maxLinearAcceleration(Current statorCurrentLimit) {
        return moduleSimulations[0].config.maxAcceleration(
                config.robotMass, moduleSimulations.length, statorCurrentLimit);
    }

    /**
     *
     *
     * <h2>Obtains the drive base radius of the swerve drive.</h2>
     *
     * @return the drive base radius.
     */
    public Distance driveBaseRadius() {
        return config.driveBaseRadius();
    }

    /**
     *
     *
     * <h2>Obtains the maximum achievable angular velocity of the chassis.</h2>
     *
     * @return the maximum angular velocity
     */
    public AngularVelocity maxAngularVelocity() {
        return RadiansPerSecond.of(maxLinearVelocity().in(MetersPerSecond)
                / config.driveBaseRadius().in(Meters));
    }

    /**
     *
     *
     * <h2>Obtains the maximum achievable angular acceleration of the chassis.</h2>
     *
     * @return the maximum angular acceleration
     */
    public AngularAcceleration maxAngularAcceleration(Current statorCurrentLimit) {
        return RadiansPerSecondPerSecond.of(moduleSimulations[0]
                        .config
                        .getTheoreticalPropellingForcePerModule(
                                config.robotMass, moduleSimulations.length, statorCurrentLimit)
                        .in(Newtons)
                * moduleTranslations[0].getNorm()
                * moduleSimulations.length
                / super.getMass().getInertia());
    }

    /**
     *
     *
     * <h2>Calculates the dynamic weight distribution across modules based on center of mass offset and acceleration.
     * </h2>
     *
     * <p>This method calculates the weight on each module accounting for:
     *
     * <ul>
     *   <li>Static weight distribution based on center of mass offset (modules closer to center of mass bear more
     *       weight)
     *   <li>Dynamic weight transfer due to acceleration (weight shifts in the direction opposite to acceleration)
     * </ul>
     *
     * <p>When accelerating forward, weight shifts to rear modules. When decelerating, weight shifts to front modules.
     * When turning, weight shifts to outside modules.
     *
     * @return an array of weight forces (in newtons) for each module
     */
    private double[] calculateDynamicWeightDistribution() {
        /*
            Matrix form of the equations:
            [1,  1,  1,  1]   [W_1]    [m * g]                           (sum of all weights)
            [1,  -1,  -1,  1] [W_2]    [0]                               (diagonal sum of weights are equal)
            [x1, x2, x3, x4]  [W_3] =  [m * g * x_com - m * a_com_x * z_com] (x direction weight transfer)
            [y1, y2, y3, y4]  [W_4]    [m * g * y_com + m * a_com_y * z_com] (y direction weight transfer)

            For a symmetrical rectangle with modules at:
            Module 1: (L/2, W/2), Module 2: (L/2, -W/2), Module 3: (-L/2, W/2), Module 4: (-L/2, -W/2)

            Solved using closed-form algebraic solution:
            W_1 = (m*g)/4 + (m*g*x_com - m*a_com_x*z_com)/(2*L) + (m*g*y_com + m*a_com_y*z_com)/(2*W)
            W_2 = (m*g)/4 + (m*g*x_com - m*a_com_x*z_com)/(2*L) - (m*g*y_com + m*a_com_y*z_com)/(2*W)
            W_3 = (m*g)/4 - (m*g*x_com - m*a_com_x*z_com)/(2*L) + (m*g*y_com + m*a_com_y*z_com)/(2*W)
            W_4 = (m*g)/4 - (m*g*x_com - m*a_com_x*z_com)/(2*L) - (m*g*y_com + m*a_com_y*z_com)/(2*W)
        */

        final double mg = totalWeightNewtons;
        final double massKg = config.robotMass.in(Kilograms);
        final double L = config.trackLengthX().in(Meters);
        final double W = config.trackWidthY().in(Meters);
        final double xCom = centerOfMassOffset.getX();
        final double yCom = centerOfMassOffset.getY();
        final double zCom = config.centerOfMass.getZ();

        final ChassisSpeeds currentSpeeds = getDriveTrainSimulatedChassisSpeedsRobotRelative();
        final double dt = SimulatedArena.getSimulationDt().in(Seconds);

        // Calculate accelerations of the geometric center of the robot
        final double chassisAccelX = (currentSpeeds.vxMetersPerSecond - previousChassisSpeeds.vxMetersPerSecond) / dt;
        final double chassisAccelY = (currentSpeeds.vyMetersPerSecond - previousChassisSpeeds.vyMetersPerSecond) / dt;
        final double chassisOmega = currentSpeeds.omegaRadiansPerSecond;
        final double chassisAlpha =
                (currentSpeeds.omegaRadiansPerSecond - previousChassisSpeeds.omegaRadiansPerSecond) / dt;

        // Calculate acceleration of center of mass
        // a_com = a_geometric_center + alpha × r_com + omega × (omega × r_com)
        final double omegaSquared = chassisOmega * chassisOmega;
        final double a_com_x = chassisAccelX - chassisAlpha * yCom - omegaSquared * xCom;
        final double a_com_y = chassisAccelY + chassisAlpha * xCom - omegaSquared * yCom;

        // Calculate the right-hand side terms
        final double rhsX = mg * xCom - massKg * a_com_x * zCom;
        final double rhsY = mg * yCom + massKg * a_com_y * zCom;

        // Base weight per module (quarter of total weight)
        final double baseWeight = mg / 4.0;

        // Weight transfer terms
        final double xTransfer = rhsX / (2.0 * L);
        final double yTransfer = rhsY / (2.0 * W);

        final double W1 = baseWeight + xTransfer + yTransfer;
        final double W2 = baseWeight + xTransfer - yTransfer;
        final double W3 = baseWeight - xTransfer + yTransfer;
        final double W4 = baseWeight - xTransfer - yTransfer;

        // Check if any weights are negative (this means that wheels are lifting off the ground)
        // In this situation, all bets are off
        // So clamp the negative weights to zero, and rescale the rest to sum to total weight
        double[] weights = new double[] {W1, W2, W3, W4};
        double sumPositives = 0.0;
        for (int i = 0; i < weights.length; i++) {
            if (weights[i] < 0) {
                weights[i] = 0.0;
            } else {
                sumPositives += weights[i];
            }
        }

        for (int i = 0; i < weights.length; i++) {
            weights[i] *= totalWeightNewtons / sumPositives;
        }
        return weights;
    }

    public SwerveModuleSimulation[] getModules() {
        return moduleSimulations;
    }

    public GyroSimulation getGyroSimulation() {
        return this.gyroSimulation;
    }
}
