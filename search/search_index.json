{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#elevating-frc-java-robot-simulations-to-the-next-level-with-physics-engines","title":"Elevating FRC Java Robot Simulations to the Next Level with Physics EnginesAnd the best part? You can achieve all of this without needing a real robot on hand!","text":"Why a Physics Engine? <p><p>     A simulation engine is a powerful tool that provides realistic approximations of physical systems. With      maple-sim, we integrate the open-source Java rigid-body dynamics engine,      dyn4j, capable of simulating 2D forces and collisions      between rigid shapes. This integration transforms the scope of robot simulations by enabling realistic      interactions between robots, field elements, and game pieces. </p> <p>     Before maple-sim, most FRC robot simulations focused solely on the robot itself\u2014its      sensors, movements, and internal operations. Now, through the power of physics simulation,      maple-sim allows your robot to engage directly with its environment. Imagine testing      robot interactions with obstacles, field elements, and game pieces, all within the simulated world.      A simulation that is realistic enough to feel like a video game. </p> <p>With this advanced level of simulation, the possibilities are endless. You can:</p> <ul> <li>Test autonomous modes with pinpoint accuracy.</li> <li>Fine-tune advanced TeleOp enhancement features like pathfinding-auto-alignment.</li> <li>Optimize shooters and other subsystems, all while gathering meaningful data from simulated physics.</li> </ul> </p>"},{"location":"#simulation-details","title":"Simulation Details","text":"<p>For an in-depth description of the simulations, please refer to Simulation Details</p>"},{"location":"#getting-started-with-templates","title":"Getting Started With Templates","text":"<ul> <li> <p>CTRE Generated Swerve Code</p> <p>The CTRE Generated Swerve Code, enhanced with maple-sim integration for improved chassis physics simulation. </p> <p> Project Page</p> </li> <li> <p>YAGSL</p> <p>Maple-sim is officially included in the amazing Yet Another Generic Swervedrive Library (YAGSL) for 2025!</p> <p> YAGSL 2025 release</p> </li> <li> <p>AdvantageKit SparkMax Swerve Template</p> <p>The AdvantageKit Swerve Template with REV SparkMax hardware, enhanced with maple-sim integration for improved chassis physics simulation. </p> <p> Project Page</p> </li> <li> <p>AdvantageKit Talon Swerve Template</p> <p>The AdvantageKit Swerve Template with CTRE hardware, enhanced with maple-sim integration for improved chassis physics simulation. </p> <p> Project Page</p> </li> <li> <p>AdvantageKit Talon Swerve Template - Enhanced Version</p> <p>A further enhanced version of the TalonSwerveTemplate-maple-sim project, utilizing Phoenix 6 simulation to simulate CTRE motor controller closed-loops and the CAN bus</p> <p> Project Page</p> </li> <li> <p>Base Talon Swerve</p> <p>Base-Talon-Swerve, modified with advanced drivetrain simulation. This is an example implementation of the Simplified Swerve Simulation.</p> <p> Project Page</p> </li> </ul> Other Custom Templates &amp; Examples <p>Maple-Swerve-Skeleton: Our custom swerve drive project based on the Advanced Swerve Drive Project, featuring drivetrain simulation, vision simulation, and convenient control features.</p> <p>5516-2024-OffSeason-RobotCode: Our 2024 off-season robot code, which implements a range of advanced simulations. This code can be run on a real robot and even played like a video game. Watch the Videos</p>"},{"location":"#online-documentation","title":"Online Documentation","text":"<p>Please follow the guides below for quick setup:</p> <ol> <li>Installing maple-sim</li> <li>Using the Simulated Arena</li> <li>Simulating Swerve Drivetrain</li> <li>Simulating Intake</li> <li>Simulating Projectiles</li> <li>Simulating Opponent Robots</li> </ol> <p>\ud83d\ude4f  Big thanks to @GrahamSH-LLK for all the help in setting up the online documentation.</p>"},{"location":"#java-docs","title":"Java Docs","text":"<p> Go to javadocs.</p> <p>\ud83d\ude4f  Big thanks to @nstrike for all the help in setting up the Java Docs.</p>"},{"location":"#reporting-bugs-developing-and-contributing","title":"Reporting Bugs, Developing and Contributing","text":"<p>Reporting Bugs</p> <p>If you've encountered a bug while using maple-sim in your robot code, please submit an issue and select the \"Bug Report\" option.  We review issues regularly and will respond as quickly as possible.</p> <p>Suggestions &amp; Improvements</p> <ul> <li>If you have an idea for a new feature, please submit an issue and select the \"Feature Request\" option.</li> <li>If you think the API for an existing feature could be improved for better readability or usability, please submit an issue and select the \"API Enhancement\" option.</li> </ul> <p>Contributing</p> <p>For detailed guidelines on contributing to the project, please refer to the contribution guide.</p>"},{"location":"CONTRIBUTION/","title":"How to Contribute","text":"<p>\ud83d\ude4f First, we want to express our heartfelt thanks for taking the time to read this. Your willingness to contribute means a lot to us! By supporting this project, you're helping to extend the values of FIRST and the spirit of open source. Contributors like you are essential to making this project better, and we are truly grateful for your involvement.</p>"},{"location":"CONTRIBUTION/#creating-a-fork","title":"Creating a fork","text":"<p>Before you start working on the code, you'll need to create a fork. Make sure to avoid selecting the \"Copy the main branch only\" option.</p> <p>Once you've created your fork, pull the code locally and get started!</p>"},{"location":"CONTRIBUTION/#code-style-guidelines","title":"Code Style Guidelines","text":"<p>When writing code for the project (excluding templates and examples), please adhere to the following guidelines:</p> <p>Tip</p> <p>We use Spotless for automatic formatting. Your code will be formatted every time you compile it.</p> <p>Things you should do</p> <ul> <li> Be a \"never nester\". See this video for an explanation. </li> <li> <p>Use <code>camelCase</code> for variables and <code>ALL_CAPS</code> for constants.</p> </li> <li> Ensure variable/constant names are descriptive and self-explanatory. e.g., <code>differenceBetweenGroundAndDesiredVelocityMetersPerSecond</code>, <code>ROBOT_MASS_WITH_BUMPERS</code>. </li> <li> Use WPILib units library for configurations and APIs. It\u2019s fine to use <code>double</code> for intermediate variables during computation, but make sure to use SI units and put units to the variable name (e.g., <code>rawMotorTorqueNewtonMeters</code>, <code>delaySeconds</code>). </li> <li> Add Javadocs for all public functions and constructors. Method Javadocs should begin with a <code>&lt;h2&gt;</code> title. </li> <li> <p>Provide references for math/physics equations used in your code.</p> </li> </ul> <p>Things to avoid</p> <ul> <li> <p>Avoid using <code>m_variable</code> or <code>k_variable</code> to distinguish constants from variables.\"</p> </li> <li> Avoid excessively long files.\" i.e. files longer than 600 lines. </li> </ul>"},{"location":"CONTRIBUTION/#testing-your-code","title":"Testing your code","text":"<p>To test your code, update the version name in <code>./project/publish.gradle</code>:</p> <pre><code>// def pubVersion = '0.2.0'\n// change version to:\ndef pubVersion = 'my-new-feature-preview'\n</code></pre> <p>Next, open the project in IntelliJ and click \"Publish to Maven Local.\"</p> <p></p> <p>Now that the library is on your local machine, copy <code>./docs/vendordep/maple-sim.json</code> to the vendordeps directory of one of the templates to test your code.</p>"},{"location":"CONTRIBUTION/#creating-a-pr","title":"Creating a PR","text":"<p>Once you've tested your code and confirmed that it works, you can create a Pull Request towards our repo: - If you're fixing a known bug, please create the PR against the <code>main</code> branch. - If you're working on a new feature that already has a branch, create the PR towards that specific branch (e.g., <code>Shenzhen-Robotics-Alliance/maple-sim/tree/a-new-feature</code>). - If you're working on a new feature that doesn't have a dedicated branch, please create the PR against the <code>dev</code> branch. Be sure to include detailed descriptions of the changes you made.</p> <p>If your PR includes API changes, it's recommended to update the documentation (<code>./docs/</code>) and example projects (<code>./templates/</code>) as part of the PR.</p>"},{"location":"CONTRIBUTION/#stay-in-touch-with-us-on-discord","title":"Stay in touch with us on discord!","text":"<p>For smoother collaboration, please join our discord community!</p>"},{"location":"installing-maple-sim/","title":"Installing maple-sim","text":"<p>Copy the following URL and install a library online with WPILib VSCode</p> <pre><code>https://shenzhen-robotics-alliance.github.io/maple-sim/vendordep/maple-sim.json\n</code></pre> <p>Alternatively, you can download the JSON vendordeps file and place it in the <code>/vendordeps</code> directory:</p> <p>Download JSON vendordeps file</p> <p>Tip</p> <p>If you're using IntelliJ IDEA, remember to click the \"Gradle sync\" button after configuring the repository.</p> <p>\ud83d\ude4f Big thanks to @nstrike for all the help in setting up the vendordeps deployment. </p>"},{"location":"reefscape/","title":"2025 Reefscape Simulation","text":""},{"location":"reefscape/#coral-and-algae-on-the-field","title":"CORAL and ALGAE on the Field","text":"<p>CORAL and ALGAE can be added to the field as game pieces:</p> <pre><code>SimulatedArena.getInstance().addGamePiece(new ReefscapeCoral(\n    // We must specify a heading since the coral is a tube\n    new Pose2d(2, 2, Rotation2d.fromDegrees(90))));\n\nSimulatedArena.getInstance().addGamePiece(new ReefscapeAlgaeOnField(new Translation2d(2,2)));\n</code></pre> <p>You can visualize them by calling:</p> <pre><code>Logger.recordOutput(\"FieldSimulation/Algae\", \n    SimulatedArena.getInstance().getGamePiecesArrayByType(\"Algae\"));\nLogger.recordOutput(\"FieldSimulation/Coral\", \n    SimulatedArena.getInstance().getGamePiecesArrayByType(\"Coral\"));\n</code></pre> <p>And display the data in AdvantageScope:</p> <p></p> <p></p> <p>Detailed Documents on Game Pieces Simulation</p> <p> Adding Game Pieces to the Field</p> <p> Visualizing Game Pieces</p>"},{"location":"reefscape/#the-coral-algae-stack","title":"The CORAL-ALGAE Stack","text":"<p>CORAL are staged on the field with ALGAE on top. You can place these stacks on the field:</p> <pre><code>SimulatedArena.getInstance().addGamePiece(new ReefscapeCoralAlgaeStack(new Translation2d(2,2)));\n</code></pre> <p>Or reset the layout by performing a field reset:</p> <pre><code>SimulatedArena.getInstance().resetFieldForAuto();\n</code></pre> <p>Tip</p> <p>When you display CORAL and ALGAE using the method specified above, the CORAL and ALGAE in the stacks will also be displayed.</p> <p></p> <p>Tip</p> <p>Stacks will collapse and become a CORAL and ALGAE on the field if you hit them:</p> <p></p>"},{"location":"reefscape/#interacting-with-coral-and-algae","title":"Interacting with CORAL and ALGAE","text":"<p>Users can use <code>IntakeSimulation</code> to simulate the interaction between robot intakes and the game pieces. </p> <pre><code>this.intakeSimulation = IntakeSimulation.OverTheBumperIntake(\n        // Specify the type of game pieces that the intake can collect\n        \"Coral\",\n        // Specify the drivetrain to which this intake is attached\n        driveTrainSimulation,\n        // Width of the intake\n        Meters.of(0.4),\n        // The extension length of the intake beyond the robot's frame (when activated)\n        Meters.of(0.2),\n        // The intake is mounted on the back side of the chassis\n        IntakeSimulation.IntakeSide.BACK,\n        // The intake can hold up to 1 note\n        1);\n</code></pre> <p>Detailed Documents on IntakeSimulation</p> <p> Simulating Intake</p> <p>Tip</p> <ul> <li>If your <code>IntakeSimulation</code> is targeted to CORAL, it will also be able to grab the CORAL from the CORAL-ALGAE stack. And the ALGAE will fall to the ground as the CORAL disapear.</li> <li>Vise versa, if your <code>IntakeSimulation</code> is targeted to ALGAE, it will also be able to grab the ALGAE from the CORAL-ALGAE stack. And the CORAL will fall to the ground as the ALGAE disapear.</li> </ul>"},{"location":"reefscape/#launching-algae-into-the-air","title":"Launching ALGAE into the air","text":"<p>ALGAE can be launched into the air, and the simulation will detect if it reaches its target\u2014the NET.</p> <pre><code>ReefscapeAlgaeOnFly.setHitNetCallBack(() -&gt; System.out.println(\"ALGAE hits NET!\"));\nSimulatedArena.getInstance()\n    .addGamePieceProjectile(new ReefscapeAlgaeOnFly(\n        driveSimulation.getSimulatedDriveTrainPose().getTranslation(),\n        new Translation2d(),\n        driveSimulation.getDriveTrainSimulatedChassisSpeedsFieldRelative(),\n        driveSimulation.getSimulatedDriveTrainPose().getRotation(),\n        0.4, // initial height of the ball, in meters\n        9, // initial velocity, in m/s\n        Math.toRadians(70)) // shooter angle\n        .withProjectileTrajectoryDisplayCallBack(\n            (poses) -&gt; Logger.recordOutput(\"successfulShotsTrajectory\", poses.toArray(Pose3d[]::new)),\n            (poses) -&gt; Logger.recordOutput(\"missedShotsTrajectory\", poses.toArray(Pose3d[]::new))));\n</code></pre> <p>See Simulating Projectiles.</p> <p></p>"},{"location":"reefscape/#scoring-coral-on-reef","title":"Scoring CORAL on REEF","text":"<p>You can eject a CORAL from your scoring mechanism during simulation. If a CORAL ejected into the air is in contact with a BRANCH at the correct angle, it will be attached to that branch. Maple-Sim will automatically detect the contact and simulate the scoring process (requires v0.3.3 or above).</p> Scoring on L3 branchScoring on L4 branch <pre><code>SimulatedArena.getInstance()\n    .addGamePieceProjectile(new ReefscapeCoralOnFly(\n        // Obtain robot position from drive simulation\n        driveSimulation.getSimulatedDriveTrainPose().getTranslation(),\n        // The scoring mechanism is installed at (0.46, 0) (meters) on the robot\n        new Translation2d(0.35, 0),\n        // Obtain robot speed from drive simulation\n        driveSimulation.getDriveTrainSimulatedChassisSpeedsFieldRelative(),\n        // Obtain robot facing from drive simulation\n        driveSimulation.getSimulatedDriveTrainPose().getRotation(),\n        // The height at which the coral is ejected\n        Meters.of(1.28),\n        // The initial speed of the coral\n        MetersPerSecond.of(2),\n        // The coral is ejected at a 35-degree slope\n        Degrees.of(-35)));\n</code></pre> <pre><code>SimulatedArena.getInstance()\n    .addGamePieceProjectile(new ReefscapeCoralOnFly(\n        // Obtain robot position from drive simulation\n        driveSimulation.getSimulatedDriveTrainPose().getTranslation(),\n        // The scoring mechanism is installed at (0.46, 0) (meters) on the robot\n        new Translation2d(0.46, 0),\n        // Obtain robot speed from drive simulation\n        driveSimulation.getDriveTrainSimulatedChassisSpeedsFieldRelative(),\n        // Obtain robot facing from drive simulation\n        driveSimulation.getSimulatedDriveTrainPose().getRotation(),\n        // The height at which the coral is ejected\n        Meters.of(2.1),\n        // The initial speed of the coral\n        MetersPerSecond.of(1),\n        // The coral is ejected vertically downwards\n        Degrees.of(-90)));\n</code></pre> <p>Info</p> <p>CORALs that miss the target will be dropped on the floor:</p> <p></p> <p>Info</p> <p>CORALs that fall on the TROUGH will remain on the trough:</p> <p></p> <p>Info</p> <p>To score a CORAL on a BRANCH, it must:</p> <ul> <li>Be in contact with the BRANCH.</li> <li>Be aligned with the direction of the BRANCH.</li> <li>Be moving in the correct direction (i.e., if the coral is moving upwards, it cannot score).</li> </ul> <p> </p>"},{"location":"reefscape/#configuring-angle-tolerance-for-scoring","title":"Configuring Angle Tolerance for Scoring","text":"<p>By default, CORAL must be aligned within 10 degrees of the BRANCH direction to score. You can adjust this tolerance to make scoring easier or harder:</p> <pre><code>// Make scoring more forgiving (allow 15 degrees of misalignment)\nReefscapeReefBranch.setAngleTolerance(Degrees.of(15));\n\n// Make scoring more strict (allow only 5 degrees of misalignment)\nReefscapeReefBranch.setAngleTolerance(Degrees.of(5));\n</code></pre> <p>Tip</p> <ul> <li>You can call <code>setAngleTolerance()</code> at any time, even after the arena has been created</li> <li>The change applies immediately to all existing branches</li> <li>This is useful for testing your scoring mechanism with different difficulty levels</li> </ul> <p>Use Case: Testing Scoring Consistency</p> <pre><code>// During testing, use a more forgiving tolerance\nReefscapeReefBranch.setAngleTolerance(Degrees.of(20));\n\n// Once your mechanism is reliable, test with competition tolerance\nReefscapeReefBranch.setAngleTolerance(Degrees.of(10));\n\n// For extra challenge, test with stricter tolerance\nReefscapeReefBranch.setAngleTolerance(Degrees.of(5));\n</code></pre> <p>To obtain the amount of corals scored on each branch, use:</p> <pre><code>Optional&lt;ReefscapeReefSimulation&gt; reefSimulation = ReefscapeReefSimulation.getInstance();\nint amountOfCoralsOnBranch_G_L4 = 0;\nif (reefSimulation.isPresent()) {\n    amountOfCoralsOnBranch_G_L4 = reefSimulation.get().getBranches()\n        [6] // branch G\n        [3]; // L4\n}\n</code></pre> <p>See the javadocs for more info.</p>"},{"location":"simulating-intake/","title":"Simulating Intake","text":"<p>Info</p> <p>You are reading the documentation for a Beta version of maple-sim. API references are subject to change in future versions.</p>"},{"location":"simulating-intake/#0-overview","title":"0. Overview","text":"<p>Intakes, or mechanisms that extend from the robot to collect game pieces from the field, are simulated by the <code>IntakeSimulation</code> class.</p> <p>The intake is modeled as a 2D shape attached to one side of the robot's chassis. Intakes are represented as rectangles with a fixed width.</p> <p> </p> <p>When deactivated, the rectangle is removed from the collision space, representing the intake retracting back into the robot\u2019s frame.</p> <p>When activated, the rectangle is added to the robot's collision space in the physics engine, simulating an intake that extends outward for a certain length.</p> <p>This class simulates an idealized \"touch it, get it\" intake, meaning that when the intake is turned on, game pieces of the specified type are immediately collected upon contact \u2014 regardless of whether they are pushed towards the intake.</p> <p>Tip</p> <p>This simulation is intended for testing code and does not exactly replicate how your real intake mechanism works.</p>"},{"location":"simulating-intake/#1-creating-intake-simulation","title":"1. Creating Intake Simulation","text":"<p>You need to create an instance of <code>IntakeSimulation</code> in your <code>IntakeIOSim</code>.</p> <pre><code>// subsystems/intake/IntakeIOSim.java\npublic class IntakeIOSim {\n    private final IntakeSimulation intakeSimulation;\n    public IntakeIOSim(AbstractDriveTrainSimulation driveTrain) {\n        // Here, create the intake simulation with respect to the intake on your real robot\n        this.intakeSimulation = new IntakeSimulation(...);\n    }\n}\n</code></pre> In-The-Frame (ITF) IntakesOver-The-Bumper (OTB) IntakesCustom Shape Intakes <p> <pre><code>this.intakeSimulation = IntakeSimulation.InTheFrameIntake(\n        // Specify the type of game pieces that the intake can collect\n        \"Note\",\n        // Specify the drivetrain to which this intake is attached\n        driveTrainSimulation,\n        // Specify width of the intake\n        Meters.of(0.7),\n        // The intake is mounted on the back side of the chassis\n        IntakeSimulation.IntakeSide.BACK,\n        // The intake can hold up to 1 note\n        1);\n</code></pre> </p> <p> <pre><code>this.intakeSimulation = IntakeSimulation.OverTheBumperIntake(\n        // Specify the type of game pieces that the intake can collect\n        \"Note\",\n        // Specify the drivetrain to which this intake is attached\n        driveTrainSimulation,\n        // Width of the intake\n        Meters.of(0.7),\n        // The extension length of the intake beyond the robot's frame (when activated)\n        Meters.of(0.2),\n        // The intake is mounted on the back side of the chassis\n        IntakeSimulation.IntakeSide.BACK,\n        // The intake can hold up to 1 note\n        1);\n</code></pre> </p> <p> <pre><code>this.intakeSimulation = new IntakeSimulation(\n        // Specify the type of game pieces that the intake can collect\n        \"Note\",\n        // Specify the drivetrain to which this intake is attached\n        driveTrainSimulation, \n        // Our intake has a custom shape of a triangle (shape is specified in chassis frame-of-reference)\n        new Triangle(new Vector2(0, 0), new Vector2(0.2, 0), new Vector2(0, 0.2)),\n        // The intake can hold up to 1 note\n        1);\n</code></pre> </p> <p>Tip</p> <p>Use setCustomIntakeCondition(Predicate&lt;GamePieceOnFieldSimulation&gt;) to define a custom condition which controls which game pieces can enter the intake. Example usage: if you want your simulated intake to only intake game pieces that are in a specific orentation.</p>"},{"location":"simulating-intake/#2-using-intake-simulation","title":"2. Using intake simulation","text":"<p>Next, implement the methods defined by the <code>IntakeIO</code> interface.</p> <p>Intakes can be turned on and off by calling <code>startIntake()</code> and <code>stopIntake()</code>. Most intakes detect game pieces inside the mechanism (usually with a beam breaker sensor). You can simulate this by checking <code>gamePiecesInIntakeCount</code>.</p> <pre><code>public class IntakeIOSim implements IntakeIO {\n    ...\n\n    @Override // Defined by IntakeIO\n    public void setRunning(boolean runIntake) {\n        if (runIntake)\n            intakeSimulation.startIntake(); // Extends the intake out from the chassis frame and starts detecting contacts with game pieces\n        else\n            intakeSimulation.stopIntake(); // Retracts the intake into the chassis frame, disabling game piece collection\n    }\n\n    @Override // Defined by IntakeIO\n    public boolean isNoteInsideIntake() {\n        return intakeSimulation.getGamePiecesAmount() != 0; // True if there is a game piece in the intake\n    }\n\n    @Override // Defined by IntakeIO\n    public void launchNote() {\n        // if there is a note in the intake, it will be removed and return true; otherwise, returns false\n        if (intakeSimulation.obtainGamePieceFromIntake())\n            ShooterIOSim.launchNote(); // notify the simulated flywheels to launch a note\n    }\n}\n</code></pre> <p>Tip</p> <p>As shown in the code above, you can notify <code>FlyWheelIOSim</code> (the simulated flywheel mechansim) to shoot the note out when the note is passed to the shooter from the intake. See Simulating GamePiece Projectiles for more details.</p> <p>If you want to simulate how the note moves inside the intake/feeder, you can take the indefinite integral of the intake/feeder voltage over time since the note entered the intake.  This gives an approximation of the note's position in the feeder.</p> <p>An example of simulating an intake together with flywheels can be found here.</p>"},{"location":"simulating-opponent-robots/","title":"Simulating Opponent Robots - an option","text":"<p>Info</p> <p>You are reading the documentation for a Beta version of maple-sim. API references are subject to change in future versions.</p>"},{"location":"simulating-opponent-robots/#0-overview","title":"0. Overview","text":"<p>Opponent robots can be added to the field for realistic driver practice. They can be programmed to perform the following tasks:</p> <ul> <li>Automatically cycle across the field, helping drivers practice offense skills with other robots present.</li> <li>Automatically run feed-cycles to deliver feed-shot notes, assisting with front-field cleanup and feeder strategies.</li> <li>Be controlled by a joystick to play defense, allowing drivers to practice defense and counter-defense skills.</li> </ul> <p></p> <p>This document discusses ONE APPROACH to achieve opponent robot simulation based on the AIRobotInSimulation class from Maple-Swerve-Skeleton.  However, once you understand the principles, we encourage you to create your own simulation utility classes to fit your specific needs.</p>"},{"location":"simulating-opponent-robots/#1-creating-opponent-robots","title":"1. Creating Opponent Robots","text":"<p>Opponent robots are simulated using the <code>SimplifiedSwerveDriveSimulation</code> class. A container class is required to manage the instances.</p> <p>When opponent robots are not actively on the field, they are positioned in \"queening\" areas outside the field to avoid unnecessary interactions.</p> <pre><code>public class AIRobotInSimulation extends SubsystemBase {\n    /* If an opponent robot is not on the field, it is placed in a queening position for performance. */\n    public static final Pose2d[] ROBOT_QUEENING_POSITIONS = new Pose2d[] {\n        new Pose2d(-6, 0, new Rotation2d()),\n        new Pose2d(-5, 0, new Rotation2d()),\n        new Pose2d(-4, 0, new Rotation2d()),\n        new Pose2d(-3, 0, new Rotation2d()),\n        new Pose2d(-2, 0, new Rotation2d())\n    };\n\n    private final SimplifiedSwerveDriveSimulation driveSimulation;\n    private final Pose2d queeningPose;\n    private final int id;\n\n    public AIRobotInSimulation(int id) {\n        this.id = id;\n        this.queeningPose = ROBOT_QUEENING_POSITIONS[id];\n        this.driveSimulation = new SimplifiedSwerveDriveSimulation(new SwerveDriveSimulation(\n            DRIVETRAIN_CONFIG, \n            queeningPose\n        ));\n\n        SimulatedArena.getInstance().addDriveTrainSimulation(\n            driveSimulation.getDriveTrainSimulation()\n        );\n    }\n}\n</code></pre>"},{"location":"simulating-opponent-robots/#2-controlling-opponent-robots-to-auto-cycle","title":"2. Controlling Opponent Robots to Auto-Cycle","text":"<p>Use PathPlanner to enable opponent robots to auto-cycle.</p>"},{"location":"simulating-opponent-robots/#configuring-pathplanner","title":"Configuring PathPlanner","text":"<pre><code>public class AIRobotInSimulation extends SubsystemBase {\n    ... // previous code not shown\n\n    // PathPlanner configuration\n    private static final RobotConfig PP_CONFIG = new RobotConfig(\n            55, // Robot mass in kg\n            8,  // Robot MOI\n            new ModuleConfig(\n                    Units.inchesToMeters(2), 3.5, 1.2, DCMotor.getFalcon500(1).withReduction(8.14), 60, 1), // Swerve module config\n            0.6, 0.6 // Track length and width\n    );\n\n    // PathPlanner PID settings\n    private final PPHolonomicDriveController driveController =\n            new PPHolonomicDriveController(new PIDConstants(5.0, 0.02), new PIDConstants(7.0, 0.05));\n\n    /** Follow path command for opponent robots */\n    private Command opponentRobotFollowPath(PathPlannerPath path) {\n        return new FollowPathCommand(\n                path, // Specify the path\n                // Provide actual robot pose in simulation, bypassing odometry error\n                driveSimulation::getActualPoseInSimulationWorld,\n                // Provide actual robot speed in simulation, bypassing encoder measurement error\n                driveSimulation::getActualSpeedsRobotRelative,\n                // Chassis speeds output\n                (speeds, feedforwards) -&gt; \n                    driveSimulation.runChassisSpeeds(speeds, new Translation2d(), false, false),\n                driveController, // Specify PID controller\n                PP_CONFIG,       // Specify robot configuration\n                // Flip path based on alliance side\n                () -&gt; DriverStation.getAlliance()\n                    .orElse(DriverStation.Alliance.Blue)\n                    .equals(DriverStation.Alliance.Red),\n                this // AIRobotInSimulation is a subsystem; this command should use it as a requirement\n        );\n    }\n}\n</code></pre>"},{"location":"simulating-opponent-robots/#3-controlling-opponent-robots-with-a-joystick","title":"3. Controlling Opponent Robots with a Joystick","text":"<p>Write a joystick drive command to allow manual control of opponent robots for defense practice.</p> <pre><code>public static final Pose2d[] ROBOTS_STARTING_POSITIONS = new Pose2d[] {\n        new Pose2d(15, 6, Rotation2d.fromDegrees(180)),\n        new Pose2d(15, 4, Rotation2d.fromDegrees(180)),\n        new Pose2d(15, 2, Rotation2d.fromDegrees(180)),\n        new Pose2d(1.6, 6, new Rotation2d()),\n        new Pose2d(1.6, 4, new Rotation2d())\n};\n\n/** Joystick drive command for opponent robots */\nprivate Command joystickDrive(XboxController joystick) {\n    // Obtain chassis speeds from joystick input\n    final Supplier&lt;ChassisSpeeds&gt; joystickSpeeds = () -&gt; new ChassisSpeeds(\n            -joystick.getLeftY() * driveSimulation.maxLinearVelocity().in(MetersPerSecond),\n            -joystick.getLeftX() * driveSimulation.maxLinearVelocity().in(MetersPerSecond),\n            -joystick.getRightX() * driveSimulation.maxAngularVelocity().in(RadiansPerSecond));\n\n    // Obtain driverstation facing for opponent driver station\n    final Supplier&lt;Rotation2d&gt; opponentDriverStationFacing = () -&gt;\n            FieldMirroringUtils.getCurrentAllianceDriverStationFacing().plus(Rotation2d.fromDegrees(180));\n\n    return Commands.run(() -&gt; {\n            // Calculate field-centric speed from driverstation-centric speed\n            final ChassisSpeeds fieldCentricSpeeds = ChassisSpeeds.fromRobotRelativeSpeeds(\n                    joystickSpeeds.get(),\n                    FieldMirroringUtils.getCurrentAllianceDriverStationFacing()\n                            .plus(Rotation2d.fromDegrees(180)));\n            // Run the field-centric speed\n            driveSimulation.runChassisSpeeds(fieldCentricSpeeds, new Translation2d(), true, true);\n            }, this)\n            // Before the command starts, reset the robot to a position inside the field\n            .beforeStarting(() -&gt; driveSimulation.setSimulationWorldPose(\n                    FieldMirroringUtils.toCurrentAlliancePose(ROBOTS_STARTING_POSITIONS[id - 1])));\n}\n</code></pre>"},{"location":"simulating-opponent-robots/#4-launching-gamepieces-from-opponent-robots","title":"4. Launching Gamepieces from Opponent Robots","text":"<p>Using the Projectile Simulation in maple-sim, opponent robots can deliver feed shots or score by launching gamepieces.</p> <pre><code>private Command feedShot() {\n    return Commands.runOnce(() -&gt; SimulatedArena.getInstance()\n            .addGamePieceProjectile(new NoteOnFly(\n                            this.driveSimulation\n                                    .getActualPoseInSimulationWorld()\n                                    .getTranslation(),\n                            new Translation2d(0.3, 0),\n                            this.driveSimulation.getActualSpeedsFieldRelative(),\n                            this.driveSimulation\n                                    .getActualPoseInSimulationWorld()\n                                    .getRotation(),\n                            0.5,\n                            10,\n                            Math.toRadians(45))\n                    .enableBecomeNoteOnFieldAfterTouchGround()));\n}\n</code></pre>"},{"location":"simulating-opponent-robots/#5-managing-opponent-robots","title":"5. Managing Opponent Robots","text":"<p>Opponent robots can be managed using a \"behavior chooser,\" which is displayed on the dashboard. This allows for easy selection of behaviors such as disabling robots, running auto-cycles, or joystick driving.</p> <p></p> <p>To enable opponent robots to follow specific paths, we need to create their paths in PathPlanner. </p> <pre><code>/** Build the behavior chooser of this opponent robot and send it to the dashboard */\npublic void buildBehaviorChooser(\n        PathPlannerPath segment0,\n        Command toRunAtEndOfSegment0,\n        PathPlannerPath segment1,\n        Command toRunAtEndOfSegment1,\n        XboxController joystick) {\n    SendableChooser&lt;Command&gt; behaviorChooser = new SendableChooser&lt;&gt;();\n    final Supplier&lt;Command&gt; disable =\n            () -&gt; Commands.runOnce(() -&gt; driveSimulation.setSimulationWorldPose(queeningPose), this)\n                    .andThen(Commands.runOnce(() -&gt; driveSimulation.runChassisSpeeds(\n                            new ChassisSpeeds(), new Translation2d(), false, false)))\n                    .ignoringDisable(true);\n\n    // Option to disable the robot\n    behaviorChooser.setDefaultOption(\"Disable\", disable.get());\n\n    // Option to auto-cycle the robot\n    behaviorChooser.addOption(\n            \"Auto Cycle\", getAutoCycleCommand(segment0, toRunAtEndOfSegment0, segment1, toRunAtEndOfSegment1));\n\n    // Option to manually control the robot with a joystick\n    behaviorChooser.addOption(\"Joystick Drive\", joystickDrive(joystick));\n\n    // Schedule the command when another behavior is selected\n    behaviorChooser.onChange((Command::schedule));\n\n    // Schedule the selected command when teleop starts\n    RobotModeTriggers.teleop()\n            .onTrue(Commands.runOnce(() -&gt; behaviorChooser.getSelected().schedule()));\n\n    // Disable the robot when the user robot is disabled\n    RobotModeTriggers.disabled().onTrue(disable.get());\n\n    SmartDashboard.putData(\"AIRobotBehaviors/Opponent Robot \" + id + \" Behavior\", behaviorChooser);\n}\n\n/** Get the command to auto-cycle the robot relatively */\nprivate Command getAutoCycleCommand(\n        PathPlannerPath segment0,\n        Command toRunAtEndOfSegment0,\n        PathPlannerPath segment1,\n        Command toRunAtEndOfSegment1) {\n    final SequentialCommandGroup cycle = new SequentialCommandGroup();\n    final Pose2d startingPose = new Pose2d(\n            segment0.getStartingDifferentialPose().getTranslation(),\n            segment0.getIdealStartingState().rotation());\n\n    cycle.addCommands(\n            opponentRobotFollowPath(segment0).andThen(toRunAtEndOfSegment0).withTimeout(10));\n    cycle.addCommands(\n            opponentRobotFollowPath(segment1).andThen(toRunAtEndOfSegment1).withTimeout(10));\n\n    return cycle.repeatedly()\n            .beforeStarting(Commands.runOnce(() -&gt; driveSimulation.setSimulationWorldPose(\n                    FieldMirroringUtils.toCurrentAlliancePose(startingPose))));\n}\n</code></pre>"},{"location":"simulating-opponent-robots/#6-initializing-opponent-robots-in-simulation","title":"6. Initializing Opponent Robots in Simulation","text":"<p>Keep opponent robot instances in a static variable and initialize them during simulation startup.</p> <pre><code>public static final AIRobotInSimulation[] instances = new AIRobotInSimulation[...]; // you can create as many opponent robots as you needs\npublic static void startOpponentRobotSimulations() {\n    try {\n        instances[0] = new AIRobotInSimulation(0);\n        instances[0].buildBehaviorChooser(\n                PathPlannerPath.fromPathFile(\"opponent robot cycle path 0\"),\n                Commands.none(),\n                PathPlannerPath.fromPathFile(\"opponent robot cycle path 0 backwards\"),\n                Commands.none(),\n                new XboxController(2));\n\n        instances[1] = ...;\n        instances[1].buildBehaviorChooser(\n                PathPlannerPath.fromPathFile(\"opponent robot cycle path 1\"),\n                instances[1].shootAtSpeaker(),\n                PathPlannerPath.fromPathFile(\"opponent robot cycle path 1 backwards\"),\n                Commands.none(),\n                new XboxController(3));\n\n        ... // create more opponent robots if you need\n    } catch (Exception e) {\n        DriverStation.reportError(\"Failed to load opponent robot simulation paths, error: \" + e.getMessage(), false);\n    }\n}\n</code></pre> <p>Call this initialization in the simulation lifecycle:</p> <pre><code>// Robot.java\n@Override\npublic void simulationInit() {\n    AIRobotInSimulation.startOpponentRobotSimulations();\n}\n</code></pre>"},{"location":"simulating-projectiles/","title":"Simulating GamePiece Projectiles","text":"<p>Info</p> <p>You are reading the documentation for a Beta version of maple-sim. API references are subject to change in future versions.</p>"},{"location":"simulating-projectiles/#0-overview","title":"0. Overview","text":"<p>Projectiles are game pieces launched into the air, typically from flywheels. In maple-sim, these game pieces are modeled using basic projectile motion with gravity only.</p> <p> </p> <p>Tip</p> <p>This simulation is intended to test code logic for auto-aiming functions and measure the accuracy of your shooter optimization under simulated vision, drive, and flywheels.</p> <p>It DOES NOT replicate the projectile motion of a real game piece. You will need to use different constants for shooter optimization in the simulation and on the real robot.</p>"},{"location":"simulating-projectiles/#1-creating-a-gamepiece-projectile","title":"1. Creating a GamePiece Projectile","text":"<p>The <code>GamePieceProjectile</code> is an abstract class representing any game piece that flies in the air. You will need to create an instance of this class.</p> <p>Currently, the only subclass of <code>GamePieceProjectile</code> is <code>NoteOnFly</code>, which represents a Crescendo Note launched into the air.</p> <pre><code>NoteOnFly noteOnFly = new NoteOnFly(\n        // Specify the position of the chassis when the note is launched\n        robotSimulationWorldPose.getTranslation(),\n        // Specify the translation of the shooter from the robot center (in the shooter\u2019s reference frame)\n        new Translation2d(0.2, 0),\n        // Specify the field-relative speed of the chassis, adding it to the initial velocity of the projectile\n        chassisSpeedsFieldRelative,\n        // The shooter facing direction is the same as the robot\u2019s facing direction\n        robotSimulationWorldPose.getRotation()\n                // Add the shooter\u2019s rotation\n                + shooterRotation,\n        // Initial height of the flying note\n        0.45,\n        // The launch speed is proportional to the RPM; assumed to be 16 meters/second at 6000 RPM\n        velocityRPM / 6000 * 20,\n        // The angle at which the note is launched\n        Math.toRadians(55)\n);\n</code></pre>"},{"location":"simulating-projectiles/#2-configuring-the-gamepiece","title":"2. Configuring the GamePiece","text":""},{"location":"simulating-projectiles/#configuring-target","title":"Configuring Target","text":"<p>You can configure the projectile to have a target. If the projectile is within a tolerance range near the target during its flight, it will hit the target, disappear, and trigger a callback.</p> <p>This can be done through the following configuration:</p> <p><pre><code>noteOnFly\n        // Set the target center to the Crescendo Speaker of the current alliance\n        .withTargetPosition(() -&gt; FieldMirroringUtils.toCurrentAllianceTranslation(new Translation3d(0.25, 5.56, 2.3)))\n        // Set the tolerance: x: \u00b10.5m, y: \u00b11.2m, z: \u00b10.3m (this is the size of the speaker's \"mouth\")\n        .withTargetTolerance(new Translation3d(0.5, 1.2, 0.3))\n        // Set a callback to run when the note hits the target\n        .withHitTargetCallBack(() -&gt; System.out.println(\"Hit speaker, +2 points!\"));\n</code></pre> For this specific season, you can use <code>asSpeakerShotNote(Runnable)</code> and <code>asAmpShotNote(Runnable)</code> from <code>NoteOnFly</code>.</p> <pre><code>noteOnFly\n        // Configure the Speaker (of the current alliance) as the target of the projectile\n        .asSpeakerShotNote(() -&gt; System.out.println(\"Hit speaker, +2 points!\"));\n</code></pre> <pre><code>noteOnFly\n        // Configure the Amp (of the current alliance) as the target of the projectile\n        .asAmpShotNote(() -&gt; System.out.println(\"Hit amp, +1 point!\"));\n</code></pre>"},{"location":"simulating-projectiles/#visualizing-trajectory","title":"Visualizing Trajectory","text":"<pre><code>noteOnFly\n        // Configure callbacks to visualize the flight trajectory of the projectile\n        .withProjectileTrajectoryDisplayCallBack(\n        // Callback for when the note will eventually hit the target (if configured)\n        (pose3ds) -&gt; Logger.recordOutput(\"Flywheel/NoteProjectileSuccessfulShot\", pose3ds.toArray(Pose3d[]::new)),\n        // Callback for when the note will eventually miss the target, or if no target is configured\n        (pose3ds) -&gt; Logger.recordOutput(\"Flywheel/NoteProjectileUnsuccessfulShot\", pose3ds.toArray(Pose3d[]::new))\n        );\n</code></pre> <p>Tip</p> <p>On Advantage Scope, you can visualize the two trajectories with different colors (e.g., green and red) to see if the note missed the target.</p>"},{"location":"simulating-projectiles/#becoming-gamepieceonfieldsimulation","title":"Becoming GamePieceOnFieldSimulation","text":"<p>In this simulation, a game piece launched into the air can be configured to become a <code>GamePieceOnFieldSimulation</code> upon touchdown.</p> <p>When the projectile touches down, a <code>GamePieceOnFieldSimulation</code> will be added to the <code>SimulatedArena</code>, conserving the projectile\u2019s air velocity.</p> <pre><code>noteOnFly\n        // Configure the note projectile to become a NoteOnField upon touching the ground\n        .enableBecomeNoteOnFieldAfterTouchGround();\n</code></pre>"},{"location":"simulating-projectiles/#3-launching-the-gamepiece","title":"3. Launching the GamePiece","text":"<p>The projectile simulation is updated and visualized within the <code>SimulatedArena</code> instance.</p> <p>To register the projectile, use:</p> <pre><code>// Add the projectile to the simulated arena\nSimulatedArena.getInstance().addGamePieceProjectile(noteOnFly);\n</code></pre> <p>The real-time positions of the flying game pieces are also visualized with other game pieces, as described here.</p>"},{"location":"simulation-details/","title":"Simulation Details","text":""},{"location":"simulation-details/#swerve-drive-simulation-dynamics-with-interactive-field","title":"Swerve-Drive Simulation Dynamics with Interactive Field","text":"<p>The standout feature of this project is the integration of the dyn4j physics engine, which enables a highly realistic and interactive simulation environment.</p> <p>In traditional swerve drive simulations, the drivetrain is typically modeled using several DCMotorSim instances to simulate motor behavior. </p> <p>In maple-sim, the drivetrain simulation goes a step further by calculating the frictional and propelling forces on each swerve module.  These forces are used to model the drivetrain as a rigid body, allowing for more accurate interaction with the field environment.</p> <p></p> <p>The realistic simulation dynamics allow you to test and refine auto paths as they would perform in real-world conditions.</p> <p></p> <p>View Full Document on Swerve Simulation &gt;&gt;&gt;</p>"},{"location":"simulation-details/#odometry-vision-simulation","title":"Odometry + Vision Simulation","text":"<p>By modeling the interaction between the wheels and the floor, our simulation can replicate odometry measurement errors caused by skidding.</p> <p>Additionally, the IMU simulation includes drift, where hard impacts on the virtual robot will cause the IMU to behave similarly to how it would in real-world scenarios.</p> <p></p> <p>Beyond odometry, you can integrate photonlib to simulate how vision-based odometry can correct your robot\u2019s position.</p> <p></p>"},{"location":"simulation-details/#game-pieces-and-intake-simulation","title":"Game Pieces and Intake Simulation","text":"<p>In maple-sim, game pieces on the field have collision boundaries and can interact with the robot. The simulator also supports a fixed intake module, allowing the robot to automatically collect game pieces upon contact.</p> <p></p> <p></p> <p>View Full Document on Intake Simulation &gt;&gt;&gt;</p>"},{"location":"simulation-details/#projectile-simulation","title":"Projectile Simulation","text":"<p>In FRC, game pieces are often launched into the air.  maple-sim offers a straightforward physics simulation to model the behavior of these projectiles.</p> <p></p> <p>View Full Document on Projectile Simulation &gt;&gt;&gt;</p>"},{"location":"simulation-details/#opponent-robots-simulation","title":"Opponent Robots Simulation","text":"<p>Simulated opponent robots can be manually controlled with a gamepad for defensive play or set to follow pre-programmed cycle paths.  Just like real robots, these opponents have collision boundaries, enabling drivers to practice both defensive and offensive strategies effectively. </p>"},{"location":"swerve-sim-easy/","title":"Swerve Simulation: Simplified Swerve Simulation","text":"About this approach <p>This approach emphasizes ease of use while maintaining a reasonably accurate model of robot behavior. Although the physics simulation is realistic enough to accurately mimic your drivetrain, the code used to manipulate the simulated drivetrain is embedded into maple-sim for convenience. As a result, it may differ slightly from the code running on your real robot.</p> <p>Example</p> <p>This document is based on the BaseTalonSwerve-maple-sim Example.  Check the project for a more detailed understanding.</p>"},{"location":"swerve-sim-easy/#0-abstracting-your-drive-subsystem","title":"0. Abstracting your drive subsystem","text":"<p>Before we start, we need to create a <code>SwerveDrive</code> interface or abstract class that specifies the functions of the drive subsystem.</p> <p></p>"},{"location":"swerve-sim-easy/#example-drive-subsystem-abstraction","title":"Example drive subsystem abstraction:","text":"<p>View original source <pre><code>package frc.robot.subsystems.drive;\n\n/**\n * Represents a subsystem responsible for controlling the drive system of a robot. This includes methods for controlling\n * the movement, managing swerve drive modules, tracking the robot's position and orientation, and other related tasks.\n */\npublic interface SwerveDrive extends Subsystem {\n    void drive(ChassisSpeeds speeds, boolean fieldRelative, boolean isOpenLoop);\n\n    void setModuleStates(SwerveModuleState[] desiredStates);\n\n    ChassisSpeeds getMeasuredSpeeds();\n\n    Rotation2d getGyroYaw();\n\n    Pose2d getPose();\n\n    void setPose(Pose2d pose);\n\n    default Rotation2d getHeading() {\n        return getPose().getRotation();\n    }\n\n    default void setHeading(Rotation2d heading) {\n        setPose(new Pose2d(getPose().getTranslation(), heading));\n    }\n\n    default void zeroHeading() {\n        setHeading(new Rotation2d());\n    }\n\n    void addVisionMeasurement(Pose2d visionRobotPose, double timeStampSeconds);\n    void addVisionMeasurement(Pose2d visionRobotPoseMeters, double timestampSeconds, Matrix&lt;N3, N1&gt; visionMeasurementStdDevs);\n}\n</code></pre></p> <p>Next, we implement the interface using the real hardware of the robot. View Example</p>"},{"location":"swerve-sim-easy/#1-creating-a-simulation-drive-subsystem-implementation","title":"1. Creating a simulation drive subsystem implementation","text":"<p>Now, let's create an implementation of the <code>SwerveDrive</code> interface using a simulated swerve drivetrain.</p> <p>To do this, we will use the <code>SimplifiedSwerveDriveSimulation</code> class. This class manages and controls a SwerveDriveSimulation, similar to how your user code controls the physical chassis. Based on the commands sent by the user, it runs closed loops on the virtual drive/steer motors in the simulated drivetrain, mimicking the behavior of the real swerve drive.</p> <p>View original source <pre><code>package frc.robot.subsystems.drive;\n\npublic class MapleSimSwerve implements SwerveDrive {\n    private final SelfControlledSwerveDriveSimulation simulatedDrive;\n    private final Field2d field2d;\n\n    public MapleSimSwerve() {\n        // For your own code, please configure your drivetrain properly according to the documentation\n        final DriveTrainSimulationConfig config = DriveTrainSimulationConfig.Default();\n\n        // Creating the SelfControlledSwerveDriveSimulation instance\n        this.simulatedDrive = new SelfControlledSwerveDriveSimulation(\n                new SwerveDriveSimulation(config, new Pose2d(0, 0, new Rotation2d())));\n\n        // Register the drivetrain simulation to the simulation world\n        SimulatedArena.getInstance().addDriveTrainSimulation(simulatedDrive.getDriveTrainSimulation());\n\n        // A field2d widget for debugging\n        field2d = new Field2d();\n        SmartDashboard.putData(\"simulation field\", field2d);\n    }\n}\n</code></pre></p> <p>Now we can create wrapper methods to implement the APIs specified by the <code>SwerveDrive</code> interface:</p> <pre><code>package frc.robot.subsystems.drive;\n\npublic class MapleSimSwerve implements SwerveDrive {\n    ... // previous code not shown\n\n    @Override\n    public void drive(Translation2d translation, double rotation, boolean fieldRelative, boolean isOpenLoop) {\n        this.simulatedDrive.runChassisSpeeds(\n                new ChassisSpeeds(translation.getX(), translation.getY(), rotation),\n                new Translation2d(),\n                fieldRelative,\n                true);\n    }\n\n    @Override\n    public void setModuleStates(SwerveModuleState[] desiredStates) {\n        simulatedDrive.runSwerveStates(desiredStates);\n    }\n\n    @Override\n    public ChassisSpeeds getMeasuredSpeeds() {\n        return simulatedDrive.getMeasuredSpeedsFieldRelative(true);\n    }\n\n    @Override\n    public Rotation2d getGyroYaw() {\n        return simulatedDrive.getRawGyroAngle();\n    }\n\n    @Override\n    public Pose2d getPose() {\n        return simulatedDrive.getOdometryEstimatedPose();\n    }\n\n    @Override\n    public void setPose(Pose2d pose) {\n        simulatedDrive.setSimulationWorldPose(pose);\n        simulatedDrive.resetOdometry(pose);\n    }\n\n    @Override\n    public void addVisionMeasurement(Pose2d visionRobotPose, double timeStampSeconds) {\n        simulatedDrive.addVisionEstimation(visionRobotPose, timeStampSeconds);\n    }\n\n    @Override\n    public void addVisionMeasurement(\n            Pose2d visionRobotPoseMeters, double timestampSeconds, Matrix&lt;N3, N1&gt; visionMeasurementStdDevs) {\n        simulatedDrive.addVisionEstimation(visionRobotPoseMeters, timestampSeconds, visionMeasurementStdDevs);\n    }\n\n    @Override\n    public void periodic() {\n        // update the odometry of the SimplifedSwerveSimulation instance\n        simulatedDrive.periodic();\n\n        // send simulation data to dashboard for testing\n        field2d.setRobotPose(simulatedDrive.getActualPoseInSimulationWorld());\n        field2d.getObject(\"odometry\").setPose(getPose());\n    }\n}\n</code></pre>"},{"location":"swerve-sim-easy/#2-using-the-simulated-drivetrain","title":"2. Using the simulated drivetrain","text":"<p>In the <code>RobotContainer</code>, we store an instance of the <code>SwerveDrive</code> interface. Depending on the robot\u2019s current mode, we instantiate different types of implementations. <pre><code>// in RobotContainer.java\nprivate final SwerveDrive drive;\n\npublic RobotContainer() {\n    if (Robot.isReal()) {\n        this.drive = new TalonSwerve(); // Real implementation\n    }\n    else {\n        this.drive = new MapleSimSwerve(); // Simulation implementation\n    }\n}\n</code></pre></p> <p>Our drive commands and auto builders should ALWAYS take the interface as a dependency, regardless of whether it\u2019s a real implementation or a simulation.</p> <p>View original source <pre><code>package frc.robot.commands;\n\npublic class JoystickDrive extends Command {\n    private SwerveDrive drive;\n    ... // Other requirements\n\n    public JoystickDrive(\n            SwerveDrive drive, // Take an instance of the SwerveDrive interface as a dependency\n            ... // Other requirements (e.g., driver gamepad axis suppliers)\n    ) {\n        this.drive = drive;\n        addRequirements(drive);\n        ... // Process other requirements\n    }\n\n    @Override\n    public void execute() {\n        ... // Process command logic\n\n        drive.drive(...); // Execute the logic through APIs specified by the SwerveDrive interface\n    }\n}\n</code></pre></p> <p>We can also configure the auto builder directly within the <code>SwerveDrive</code> interface, enabling autonomous driving in both the real world and simulation.</p> <pre><code>public interface SwerveDrive extends Subsystem {\n    ... // previous code not shown\n\n    /** Configures the PathPlanner auto builder */\n    default void configurePPAutoBuilder() {\n        AutoBuilder.configure(\n                // Use APIs from SwerveDrive interface\n                this::getPose, \n                this::setPose,\n                this::getMeasuredSpeeds,\n                (speeds) -&gt; this.drive(speeds, false, true),\n\n                // Configure the Auto PIDs\n                new PPHolonomicDriveController(\n                    Constants.AUTO_TRANSLATIONAL_PID_CONSTANT, \n                    Constants.AUTO_ROTATIONAL_PID_CONSTANT),\n\n                // Specify the PathPlanner Robot Config\n                Constants.ROBOT_CONFIG,\n\n                // Path Flipping: Determines if the path should be flipped based on the robot's alliance color\n                () -&gt; DriverStation.getAlliance().orElse(DriverStation.Alliance.Blue).equals(DriverStation.Alliance.Red),\n\n                // Specify the drive subsystem as a requirement of the command\n                this);\n    }\n}\n</code></pre>"},{"location":"swerve-sim-hardware-abstraction/","title":"Swerve Simulation: Hardware Abstractions","text":"About this approach <p>This approach to simulating swerve drive accurately mimics the behavior of your drivetrain code by running the exact same code used on the real robot directly on the simulated robot. While this ensures high fidelity in the simulation, it does require a significant amount of effort to set up properly.</p> <p>Example</p> <p>For a more comprehensive understanding of how this works, please check out the AdvancedSwerveDrive-maple-sim example.</p>"},{"location":"swerve-sim-hardware-abstraction/#0-io-abstraction","title":"0. IO Abstraction","text":"<p>Tip</p> <p>If you're using AdvantageKit, your code is already IO-abstracted. You do not need to restructure your code to use maple-sim.</p> <p>The core idea is that the code for your subsystem interacts with an IO interface that can have multiple implementations.</p> <p>The code runs EXACTLY the same regardless of which IO interface it interacts with, whether on a real robot or in a physics engine.</p> <p></p> <p>Optionally, you can use the log-replay technology with AdvantageKit.</p> <p>To implement IO abstraction, you need to organize the code for EACH subsystem according to this structure:</p> <pre><code>subsystems/\n\u251c\u2500\u2500 MySubsystem/\n\u2502   \u251c\u2500\u2500 MySubsystem.java\n\u2502   \u251c\u2500\u2500 MySubsystemIO.java\n\u2502   \u251c\u2500\u2500 MySubsystemIOTalonFX.java\n\u2502   \u251c\u2500\u2500 MySubsystemIOSparkMax.java\n\u2502   \u2514\u2500\u2500 MySubsystemIOSim.java\n</code></pre> <ul> <li><code>MySubsystem.java</code>:  The main code that controls the subsystem.</li> <li><code>MySubsystemIO.java</code>: Defines the IO interface, specifying the abstract inputs and outputs of the subsystem.</li> <li><code>MySubsystemIOTalonFX.java</code>: A hardware implementation of the IO interface using Falcon motors.</li> <li><code>MySubsystemIOSparkMax.java</code>: A hardware implementation of the IO interface using Neo motors.</li> <li><code>MySubsystemIOSim.java</code>: he simulation implementation of the IO interface, which runs the physics simulation.</li> </ul> <p>Reference: io-interface.md from Advantage Kit Documents</p>"},{"location":"swerve-sim-hardware-abstraction/#1-interacting-with-the-gyro-through-io-abstraction","title":"1. Interacting with the Gyro through IO abstraction","text":"<p>The simulated gyro includes measurement errors and will drift if the robot collides with an obstacle. For accurate odometry simulation, use the simulated gyro to update the odometry.</p> <p>Create <code>GyroIOSim.java</code>, which implements <code>GyroIO</code> by wrapping around the methods of <code>GyroSimulation</code>:</p>"},{"location":"swerve-sim-hardware-abstraction/#io-interface","title":"IO interface","text":"<pre><code>// Example gyro interface\npublic interface GyroIO {\n    Rotation2d getGyroRotation();\n    AngularVelocity getGyroAngularVelocity();\n}\n</code></pre>"},{"location":"swerve-sim-hardware-abstraction/#real-implementation","title":"Real Implementation","text":"<pre><code>// real implementation with Pigeon2\npublic class GyroIOPigeon2 implements GyroIO {\n    private final Pigeon2 pigeon2;\n    public GyroIOPigeon2(...) {\n        // Implementation details\n    }\n\n    @Override // specified by GroIOSim interface\n    public Rotation2d getGyroRotation() {\n        return pigeon2.getYaw();\n    }\n\n    @Override // specified by GroIOSim interface\n    public AngularVelocity getGyroAngularVelocity() {\n        return pigeon2.getAngularVelocity();\n    }\n}\n</code></pre>"},{"location":"swerve-sim-hardware-abstraction/#simulation-implementation","title":"Simulation Implementation","text":"<pre><code>// Simulation implementation\npublic class GyroIOSim implements GyroIO {\n    private final GyroSimulation gyroSimulation;\n    public GyroIOSim(GyroSimulation gyroSimulation) {\n        this.gyroSimulation = gyroSimulation;\n    }\n\n    @Override // specified by GroIOSim interface\n    public Rotation2d getGyroRotation() {\n        return this.gyroSimulation.getGyroReading();\n    }\n\n    @Override // specified by GroIOSim interface\n    public AngularVelocity getGyroAngularVelocity() {\n        return this.gyroSimulation.getMeasuredAngularVelocity();\n    }\n}\n</code></pre> <p>If you're using AdvantageKit, you'll want to update the <code>GyroInputs</code> by retrieving data from the <code>GyroSimulation</code>.</p> <p>An example of implementing the Gyro interface in an AdvantageKit environment can be found here.</p>"},{"location":"swerve-sim-hardware-abstraction/#2-interacting-with-the-simulated-modules-through-io-abstraction","title":"2. Interacting with the Simulated Modules through IO abstraction","text":"<p>Similar to the gyro, you also need to create hardware abstractions for the swerve modules.</p> <p>To implement <code>ModuleIO</code> using the simulator, we need to obtain the reference to the simulated motor controller of the motors, and use the following API references in <code>ModuleIOSim</code>:</p> <pre><code>// This is only an example simulation IO implement, please change the code according to your ModuleIO interface\npublic class ModuleIOSim implements ModuleIO {\n    // reference to module simulation\n    private final SwerveModuleSimulation moduleSimulation;\n    // reference to the simulated drive motor\n    private final SimulatedMotorController.GenericMotorController driveMotor;\n    // reference to the simulated turn motor\n    private final SimulatedMotorController.GenericMotorController turnMotor;\n\n    public ModuleIOSim(SwerveModuleSimulation moduleSimulation) {\n        this.moduleSimulation = moduleSimulation;\n\n        // configures a generic motor controller for drive motor\n        // set a current limit of 60 amps\n        this.driveMotor = moduleSimulation\n                .useGenericMotorControllerForDrive()\n                .withCurrentLimit(Amps.of(60));\n        this.turnMotor = moduleSimulation\n                .useGenericControllerForSteer()\n                .withCurrentLimit(Amps.of(20));\n    }\n\n    @Override // specified by ModuleIO interface\n    public void setDriveOutputVoltage(Voltage voltage) {\n        this.driveMotor.requestVoltage(voltage);\n    }\n\n    @Override // specified by ModuleIO interface\n    public void setSteerOutputVoltage(Voltage voltage) {\n        this.turnMotor.requestVoltage(voltage);\n    }\n\n    @Override // specified by ModuleIO interface\n    public Rotation2d getSteerFacing() {\n        return this.moduleSimulation.getSteerAbsoluteFacing();\n    }\n\n    @Override // specified by ModuleIO interface\n    public Angle getSteerRelativePosition() {\n        return moduleSimulation.getSteerRelativeEncoderPosition().divide(moduleSimulation.STEER_GEAR_RATIO));\n    }\n\n    @Override // specified by ModuleIO interface\n    public Angle getDriveWheelrPositiond() {\n        return moduleSimulation.getDrieWheelFinalPosition()\n    }\n}\n</code></pre>"},{"location":"swerve-sim-hardware-abstraction/#3-instantiating-simulation-io-implementations","title":"3. Instantiating Simulation IO Implementations","text":"<p>When running the simulator, you can instantiate the above simulation IO implementations to allow the robot to run within the simulation environment.</p> <pre><code>// creation the swerve simulation (please refer to previous documents)\nthis.swerveDriveSimulation = new SwerveDriveSimulation(...);\n\nthis.drive = new Drive(\n        new GyroIOSim(this.swerveDriveSimulation.getGyroSimulation()),\n        new ModuleIOSim(this.swerveDriveSimulation.getModules()[0]),\n        new ModuleIOSim(this.swerveDriveSimulation.getModules()[1]),\n        new ModuleIOSim(this.swerveDriveSimulation.getModules()[2]),\n        new ModuleIOSim(this.swerveDriveSimulation.getModules()[3])\n);\n</code></pre>"},{"location":"swerve-simulation-overview/","title":"Simulating Swerve Drivetrain","text":"<p>Info</p> <p>You are reading the documentation for a Beta version of maple-sim. API references are subject to change in future versions.</p> <p>Tip</p> <p>This realistic simulation allows you to accomplish a variety of tasks without the real robot. You can practice driving, test autonomous routines, and fine-tune advanced functions such as auto-alignment, just to name a few.</p>"},{"location":"swerve-simulation-overview/#0-creating-the-configuration-for-a-swerve-drive-simulation","title":"0. Creating the Configuration for a Swerve Drive Simulation","text":"<p>The <code>DriveTrainSimulationConfig</code> object encapsulates the physical properties and configuration of a swerve drivetrain within the simulation environment. It allows you to specify key components such as motor types, gyro configuration, swerve module dynamics, and robot geometry.</p> COTS SwerveCustom SwerveCustom Swerve with Mixed Module Configurations <p> <pre><code>// Create and configure a drivetrain simulation configuration\nfinal DriveTrainSimulationConfig driveTrainSimulationConfig = DriveTrainSimulationConfig.Default()\n        // Specify gyro type (for realistic gyro drifting and error simulation)\n        .withGyro(COTS.ofPigeon2())\n        // Specify swerve module (for realistic swerve dynamics)\n        .withSwerveModule(COTS.ofMark4(\n                DCMotor.getKrakenX60(1), // Drive motor is a Kraken X60\n                DCMotor.getFalcon500(1), // Steer motor is a Falcon 500\n                COTS.WHEELS.COLSONS.cof, // Use the COF for Colson Wheels\n                3)) // L3 Gear ratio\n        // Configures the track length and track width (spacing between swerve modules)\n        .withTrackLengthTrackWidth(Inches.of(24), Inches.of(24))\n        // Configures the bumper size (dimensions of the robot bumper)\n        .withBumperSize(Inches.of(30), Inches.of(30));\n</code></pre> </p> <p> <pre><code>// Create and configure a drivetrain simulation configuration\nfinal DriveTrainSimulationConfig driveTrainSimulationConfig = DriveTrainSimulationConfig.Default()\n        // Specify gyro type (for realistic gyro drifting and error simulation)\n        .withGyro(COTS.ofPigeon2())\n        // Specify swerve module (for realistic swerve dynamics)\n        .withSwerveModule(new SwerveModuleSimulationConfig(\n                DCMotor.getKrakenX60(1), // Drive motor is a Kraken X60\n                DCMotor.getFalcon500(1), // Steer motor is a Falcon 500\n                6.12, // Drive motor gear ratio.\n                12.8, // Steer motor gear ratio.\n                Volts.of(0.1), // Drive friction voltage.\n                Volts.of(0.1), // Steer friction voltage\n                Inches.of(2), // Wheel radius\n                KilogramSquareMeters.of(0.03), // Steer MOI\n                1.2)) // Wheel COF\n        // Configures the track length and track width (spacing between swerve modules)\n        .withTrackLengthTrackWidth(Inches.of(24), Inches.of(24))\n        // Configures the bumper size (dimensions of the robot bumper)\n        .withBumperSize(Inches.of(30), Inches.of(30));\n</code></pre> </p> <p> <pre><code>final SwerveModuleSimulationConfig \n        FRONT_LEFT_MODULE_CONFIG = new SwerveModuleSimulationConfig(...),\n        FRONT_RIGHT_MODULE_CONFIG = new SwerveModuleSimulationConfig(...),\n        BACK_LEFT_MODULE_CONFIG = new SwerveModuleSimulationConfig(...),\n        BACK_RIGHT_MODULE_CONFIG = new SwerveModuleSimulationConfig(...);\n\n// Create and configure a drivetrain simulation configuration\nfinal DriveTrainSimulationConfig driveTrainSimulationConfig = DriveTrainSimulationConfig.Default()\n        // Specify gyro type (for realistic gyro drifting and error simulation)\n        .withGyro(COTS.ofPigeon2())\n        // Specify swerve module (for realistic swerve dynamics)\n        .withSwerveModules(\n                FRONT_LEFT_MODULE_CONFIG, \n                FRONT_RIGHT_MODULE_CONFIG, \n                BACK_LEFT_MODULE_CONFIG, \n                BACK_RIGHT_MODULE_CONFIG)\n        // Configures the track length and track width (spacing between swerve modules)\n        .withTrackLengthTrackWidth(Inches.of(24), Inches.of(24))\n        // Configures the bumper size (dimensions of the robot bumper)\n        .withBumperSize(Inches.of(30), Inches.of(30));\n</code></pre> </p>"},{"location":"swerve-simulation-overview/#1-instantiate-and-register-a-swerve-drive-simulation","title":"1. Instantiate and Register a Swerve Drive Simulation","text":"<p>The <code>SwerveDriveSimulation</code> class represents a simulated swerve drivetrain within the simulation environment. It provides the necessary code to simulate motors, encoders, and the dynamic behavior of a real robot, including accurate handling of controls, motor response, and motion. Additionally, it interacts with the field through its collision space, allowing the simulation to react with other objects in the physics engine.</p> <p>You can instantiate the swerve drive simulation using the following code:</p> <pre><code>/* Create a swerve drive simulation */\nthis.swerveDriveSimulation = new SwerveDriveSimulation(\n        // Specify Configuration\n        driveTrainSimulationConfig,\n        // Specify starting pose\n        new Pose2d(3, 3, new Rotation2d())\n);\n</code></pre> <p>The simulation must be registered to the simulation world for it to function correctly:</p> <pre><code>// Register the drivetrain simulation to the default simulation world\nSimulatedArena.getInstance().addDriveTrainSimulation(swerveDriveSimulation);\n</code></pre>"},{"location":"swerve-simulation-overview/#2-manipulating-the-simulated-swerve","title":"2. Manipulating the Simulated Swerve","text":"<ul> <li> <p>The simple approach</p> <p>This approach emphasizes ease of use while maintaining a reasonably accurate model of robot behavior. Although the physics simulation is realistic enough to accurately mimic your drivetrain, the code used to manipulate the simulated drivetrain is embedded into maple-sim for convenience. As a result, it may differ slightly from the code running on your real robot.</p> <p> View Documentation</p> </li> <li> <p>The professional approach</p> <p>This approach to simulating swerve drive accurately mimics the behavior of your drivetrain code by running the exact same code used on the real robot directly on the simulated robot. While this ensures high fidelity in the simulation, it does require a significant amount of effort to set up properly.</p> <p> View Documentation</p> </li> </ul>"},{"location":"using-the-simulated-arena/","title":"Using the Simulated Arena Object","text":"<p>Info</p> <p>You are reading the documentation for a Beta version of maple-sim. API references are subject to change in future versions.</p>"},{"location":"using-the-simulated-arena/#0-the-simulation-world","title":"0. The simulation world","text":"<p>maple-sim simulates the interaction between the robot and its surrounding environment. For FRC, this environment represents the FRC Arena of the current year's game.</p>"},{"location":"using-the-simulated-arena/#1-the-simulatedarena-instance","title":"1. The <code>SimulatedArena</code> instance","text":"<p>The simulation world, containing obstacles, game pieces, and robots, is stored in a <code>SimulatedArena</code> object. Most of the time, you'll only need one simulation world instance.</p> <pre><code>// Obtains the default instance of the simulation world, which is a Crescendo Arena.\nSimulatedArena.getInstance();\n// Overrides the default simulation\nSimulatedArena.overrideInstance(SimulatedArena newInstance); \n</code></pre>"},{"location":"using-the-simulated-arena/#2-updating-the-simulatedarena-instance","title":"2. Updating the <code>SimulatedArena</code> instance","text":"<p>You need to call the update function to keep the simulation world updated.</p> <pre><code>// simulation period method in your Robot.java\n@Override\npublic void simulationPeriod() {\n    SimulatedArena.getInstance().simulationPeriodic();\n}\n</code></pre> <p>Warning</p> <p>DO NOT call <code>SimulatedArena.getInstance().simulationPeriodic()</code> when running on a REAL robot, as it will drain the resources of your roboRIO.</p> <p>For each period of your robot (or each call to <code>SimulatedArena.getInstance().simulationPeriodic()</code>), the simulator processes a few sub-ticks, advancing the time incrementally and recalculating the physics model. This method ensures higher accuracy and enables simulation of high-frequency odometry.</p> <p>By default, the simulator runs 5 iterations per robot period, with the default robot period being 0.02 seconds. This allows you to simulate a typical 50Hz robot with 250Hz odometry.</p> <p>You can adjust the simulator's timing if necessary:</p> <pre><code>// Set the robot period to 1/100 second and configure 3 sub-ticks per period\n// This simulates a 100Hz robot with 300Hz odometry.\nSimulatedArena.overrideSimulationTimings(0.01, 3);\n</code></pre> <p>Warning</p> <p>DO NOT override the timing if you are using AdvantageKit, as it only supports 50Hz robots.</p>"},{"location":"using-the-simulated-arena/#3-adding-game-pieces-to-the-field","title":"3. Adding Game Pieces to the Field","text":"<p>Game pieces, such as Crescendo Notes, can be added to the field as rigid bodies with collision detection. Your robot can interact with these pieces by bumping into them or grabbing them (see Intake Simulation).</p> <p>To add or clear game pieces from the field:</p> <pre><code>// Add a Crescendo note to the field\nSimulatedArena.getInstance().addGamePiece(new CrescendoNoteOnField(new Translation2d(3, 3)));\n\n// Clear all game pieces from the field\nSimulatedArena.getInstance().clearGamePieces();\n</code></pre> <p>Tip</p> <p>In the Crescendo Simulation Arena, notes are automatically dropped from the human player station when no notes are near the source zone.   In addition to notes on field, maple-sim also provides simulation for projectiles, see Simulating GamePiece Projectiles</p>"},{"location":"using-the-simulated-arena/#4-visualizing-game-pieces","title":"4. Visualizing game pieces","text":"<p>You can retrieve the positions of game pieces, including those on the ground and those launched into the air:</p> AdvantageKitWPILib Networktables <pre><code>void periodic() {\n      // Get the positions of the notes (both on the field and in the air)\n      Pose3d[] notesPoses = SimulatedArena.getInstance()\n            .getGamePiecesArrayByType(\"Note\");\n      // Publish to telemetry using AdvantageKit\n      Logger.recordOutput(\"FieldSimulation/NotesPositions\", notesPoses);\n}\n</code></pre> <pre><code>StructArrayPublisher&lt;Pose3d&gt; notePoses = NetworkTableInstance.getDefault()\n      .getStructArrayTopic(\"MyPoseArray\", Pose3d.struct)\n      .publish();\n\nvoid periodic() {\n      // Get the positions of the notes (both on the field and in the air)\n      Pose3d[] notesPoses = SimulatedArena.getInstance()\n            .getGamePiecesArrayByType(\"Note\");\n      notePoses.accept(SimulatedArena.getInstance()\n            .getGamePiecesByType(\"Note\")\n            .toArray(Pose3d::new));\n}\n</code></pre>"},{"location":"javadocs/legal/jquery/","title":"Jquery","text":""},{"location":"javadocs/legal/jquery/#jquery-v361","title":"jQuery v3.6.1","text":""},{"location":"javadocs/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.6.1\nCopyright OpenJS Foundation and other contributors, https://openjsf.org/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n******************************************\n\nThe jQuery JavaScript Library v3.6.1 also includes Sizzle.js\n\nSizzle.js includes the following license:\n\nCopyright JS Foundation and other contributors, https://js.foundation/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/sizzle\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n\n*********************\n</code></pre>"},{"location":"javadocs/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"javadocs/legal/jqueryUI/#jquery-ui-v1132","title":"jQuery UI v1.13.2","text":""},{"location":"javadocs/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"release-notes/version0.2.0-beta1/","title":"Release Notes","text":""},{"location":"release-notes/version0.2.0-beta1/#maple-sim-beta-1-a-new-start","title":"Maple-Sim Beta 1: A New Start","text":"<p>It's been a month since we announced maple-sim alpha, a lot has happened this month.  We've got a lot of help from the community developers.  Compared to maple-sim a month ago, we are more stable, easier to use and had some features.</p>"},{"location":"release-notes/version0.2.0-beta1/#lots-of-new-features-for-beta","title":"Lots of new features for Beta!","text":""},{"location":"release-notes/version0.2.0-beta1/#1-simplified-swerve-simulation","title":"1. Simplified Swerve Simulation","text":"<p>\ud83d\ude4f Contributed by @GearFox</p> <p>The new <code>SimplifiedSwerveSimulation</code> class manages and controls a <code>SwerveDriveSimulation</code>. Similar to how your user code operates the physical chassis, it runs closed loops on the virtual drive and steer motors in the simulated drivetrain, mimicking the behavior of a real swerve drive. This provides an easier way to simulate swerve drivetrains without the need for the hardware abstraction code structure.</p> <p>Check out the documentation for more details.</p>"},{"location":"release-notes/version0.2.0-beta1/#2-motor-controller-closed-loops-simulation","title":"2. Motor Controller Closed Loops Simulation","text":"<p>\ud83d\ude4f Contributed by @oh-yes-0-fps</p> <p>The updated <code>MapleMotorSim</code> now includes a feature to simulate high-frequency closed loops running on motor controllers. This allows teams using different vendor APIs to more accurately simulate the behavior of their motor controllers during simulations.</p>"},{"location":"release-notes/version0.2.0-beta1/#3-wpilib-units-library","title":"3. WPILib Units Library","text":"<p>\ud83d\ude4f Contributed by @buwunny</p> <p>The New WPILib Units Library for 2025 has been fully implemented across the project. This improves API readability and eliminates potential issues related to unit conversions.</p>"},{"location":"release-notes/version0.2.0-beta1/#4-yagsl-officially-supported","title":"4. YAGSL, Officially Supported!","text":"<p>\ud83d\ude4f Thanks to @nstrike for making this possible!</p> <p>With help from the developers of YAGSL, we have successfully integrated maple-sim with the amazing Yet Another Generic Swerve Drive Library (2025-beta).   A preview version featuring realistic swerve simulation will be available soon. </p> <p>Please follow YAGSL on Github to stay updated when it's released.</p>"},{"location":"release-notes/version0.2.0-beta1/#more-stable-hosting","title":"More Stable Hosting","text":"<p>We are now using GitHub Pages to host the library and its documentation, providing a more reliable and stable experience than before.</p> <p>You can download the vendordeps from this url: <pre><code>https://shenzhen-robotics-alliance.github.io/maple-sim/vendordep/maple-sim.json\n</code></pre> No additional configuration is needed in Gradle\u2014simply drop the file into the <code>vendordeps/</code> directory, and the library will download automatically!</p> <p>The online documentation is available here.</p> <p>You can also access the online Javadocs here.</p>"},{"location":"release-notes/version0.2.0-beta1/#full-changelog-thanks","title":"Full Changelog &amp; Thanks","text":"<p>All the above couldn't have been possible without the help of the fellow community contributors. Deep and sincere thanks to:</p> Contributors and Their Contributions <ul> <li>@ArisaYamatogi from our team for:<ul> <li>Illustrations and diagrams in the documents.</li> </ul> </li> <li>@buwunny from Team 3173 \"IgKnighters\" for:<ul> <li>Implementing WPILib units library across the project in [#24].</li> </ul> </li> <li>@cyocom for:<ul> <li>Adding constants for WCP SwerveX modules in the swerve module factory in [#4] and [#5].</li> </ul> </li> <li>@Daniel1464 from Team 5160 \"Chargers\" for:<ul> <li>Adding safety measures in [#33].</li> <li>Fixing links in documents in [#38].</li> </ul> </li> <li>@GearFox from Team 4467 \"Titanium Titans\", my mentor who guided me to FRC, for:<ul> <li>Creating the Simplified Swerve Simulation in [#25].</li> <li>Proposing motor-controller closed-loop simulation.</li> </ul> </li> <li>@KfirNeuman from Team 3075 \"Ha-Dream Team\" for:<ul> <li>Improving the readability of the DRIVE_WHEEL_TYPE enum in [#14].</li> </ul> </li> <li>@oh-yes-0-fps from Team 3173 \"IgKnighters\" for:<ul> <li>Improving intake simulation API in [#7].</li> <li>Removing redundant PPLib usage in [#11].</li> <li>Implementing motor-controller closed-loop and battery simulation in [#18].</li> <li>(To be released) Adding the SimRobot container, enhancing the gamepiece API, and more in [#26].</li> </ul> </li> <li>@Roman-Tech-Plus from Team 5104 \"The Breakerbots\" for:<ul> <li>(To be released) Integrating maple-sim into CTRE's high-fidelity motor simulation in [#CTRE-simulation-support].</li> </ul> </li> <li>@thenetworkgrinch from YAGSL and Team 3481 \"the BroncBotz\" for:<ul> <li>Setting up vendordeps publishing in [#2].</li> <li>Setting up documents on GitHub pages.</li> <li>Setting up Javadocs and Spotless formatting in [#3].</li> <li>Bringing YAGSL beta with maple-sim to life.</li> </ul> </li> </ul> <p>Thanks for kindly contributing to this project!</p>"},{"location":"release-notes/version0.2.0-beta1/#whats-next","title":"What's Next?","text":"<p>As the title suggests, this is just the beginning for maple-sim. Our team, alongside contributors from the community, is actively working on exciting new features. We're planning to release Beta 2 next month, which will include the following updates:</p>"},{"location":"release-notes/version0.2.0-beta1/#1-simrobot-container","title":"1. SimRobot Container","text":"<p>A new <code>SimRobot</code> class that encapsulates simulation classes modeling your robot, providing a more readable and intuitive API. (Contributed by @oh-yes-0-fps)</p>"},{"location":"release-notes/version0.2.0-beta1/#2-new-gamepieces-api","title":"2. New Gamepieces API","text":"<p>A new API for simulating gamepieces, enabling teams to model how their robot processes intaken gamepieces. (Contributed by @oh-yes-0-fps)</p>"},{"location":"release-notes/version0.2.0-beta1/#3-ctre-simulation-support","title":"3. CTRE Simulation Support","text":"<p>Integration with CTRE's high-fidelity motor simulation, allowing maple-sim to deliver enhanced physics simulation for teams using the CTRE swerve API. (Contributed by @Roman-Tech-Plus and inspired by Team 5104 \"The Breakerbots\"'s Custom Library - BreakerLib)</p>"},{"location":"release-notes/version0.2.0-beta1/#lets-work-together","title":"Let's work together!","text":"<p>We warmly invite you to report bugs, suggest for new features and contribute to the project.</p> <p>We rely on the support of the community to grow and improve, and every contribution is deeply appreciated! Whether you're an experienced programmer or new to simulation, there are many ways to contribute. Not comfortable with coding? No problem! You can help by working on documentation or creating example projects.</p> <p>https://discord.com/invite/tWn45Qm6ub</p>"},{"location":"release-notes/version0.3.0-beta2/","title":"Maple-Sim Beta 2: New Season!","text":"<p>As teams DIVE IN to the new Reefscape season, we are excited to present the latest release of Maple-Sim!</p>"},{"location":"release-notes/version0.3.0-beta2/#new-season-new-game","title":"New Season, New Game","text":"<p>With the updated playing field and game elements, Maple-Sim is fully equipped to power your software development for the new season! Check out the Reefscape Simulation Notes for detailed information on season-specific simulations for the 2025 game.</p>"},{"location":"release-notes/version0.3.0-beta2/#whats-changed","title":"What's Changed","text":"<ul> <li>Update pull request template by @GrahamSH-LLK in https://github.com/Shenzhen-Robotics-Alliance/maple-sim/pull/77</li> <li>Fix a few typos in docs by @GrahamSH-LLK in https://github.com/Shenzhen-Robotics-Alliance/maple-sim/pull/76</li> <li>Update build.gradle by @thenetworkgrinch in https://github.com/Shenzhen-Robotics-Alliance/maple-sim/pull/79</li> <li>Reefscape! by @catr1xLiu in https://github.com/Shenzhen-Robotics-Alliance/maple-sim/pull/80</li> </ul> <p>Full Changelog: https://github.com/Shenzhen-Robotics-Alliance/maple-sim/compare/v0.2.8...v0.3.0</p>"},{"location":"release-notes/version0.3.0-beta2/#whats-next","title":"What's Next?","text":"<p>The following will be available later this week:</p> <p>Note: This is Maple-Sim's first season. The development process will continue as teams use it throughout the season. Expect occasional instability, bugs, and API changes as we deliver updates.  If you have any questions or concerns, please feel free to contact us on discord or submit an issue on GitHub\u2014we\u2019re here to help!</p>"},{"location":"release-notes/version0.3.0-beta2/#new-advantagekit-swerve-templates","title":"New AdvantageKit Swerve Templates","text":"<p>In the Kick-Off Release of AdvantageKit (V4.0.0), the AdvantageKit Swerve Templates have received several upgrades. We will be integrating these upgrades into our modified version of AdvantageKit Swerve Templates with Maple-Sim integration so that teams can easily use them for the new season.</p>"},{"location":"release-notes/version0.3.0-beta2/#ctre-generated-swerve-project-simulation-support","title":"CTRE Generated Swerve Project Simulation Support","text":"<p>We will provide a modified version of the CTRE Generated Swerve Project to allow teams using it to take full advantage of Maple-Sim's enhanced simulation capabilities.</p>"}]}